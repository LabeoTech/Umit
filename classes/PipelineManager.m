classdef PipelineManager < handle
    % PIPELINEMANAGER manages data processing pipelines.
    % This class allows the creation of analysis pipeline and manages the execution of
    % functions. In addition, it controls for failed / completed  steps in the pipeline.
    
    properties
        b_skipSteps logical = false % If TRUE, PIPELINEMANAGER will load existing data from the SaveFolder to skip a section of a pipeline.
        b_saveDataBeforeFail logical = false % If TRUE, the more recent data ("current_data") in the pipeline will be saved to a file when an error occurs.
        b_overwriteFiles logical = false % If TRUE, the pipeline will overwrite existing files with same names. If false, a "_n"umber will be appended to the new file name.
    end
    properties (SetAccess = {?DataViewer})
        % Structure array containing steps of the pipeline:
        funcList struct % structure containing the info about each function in the "fcnDir".
        pipe struct % pipeline structure (see corresponding Set method).
    end
    properties (Access = {?DataViewer})
        b_enforceSaving logical = true % Ensures that all data generated by the pipeline is saved. This is set to FALSE for pipeline executed in DataViewer.
        b_inputFromDataViewer logical = false % TRUE if the first input from the pipeline comes from the DataViewer app.
    end
    properties (SetAccess = private)
        % the same changes to the property's set method.
        PipelineSummary table% Shows the jobs run in the current Pipeline
        SaveFolderList cell % List of Save folders
        RawFolderList cell % List of Raw folders corresponding to the items in SaveFolderList.
    end
    properties (GetAccess = {?DataViewer})
        current_data % Data available in the workspace during pipeline.
        current_info struct% Structure with info about the functions ran on "current_data". This will be saved to the dataHistory file.
        current_saveFolder char % Current path to save folder during pipeline execution.
        current_rawFolder char % Current path to raw folder during pipeline execution.
        dataHistory struct % Local copy of the content from the dataHistory file in the data's SaveFolder.
%         dv_inputFilename % Name of the input file (DataViewer only).        
        b_state logical = false % True if a task of a pipeline was successfully executed.
    end
    properties (Access = private)
        pipe_session % Copy of the pipeline stored in "pipe" used during the pipeline execution that can be dynamically modified.
        fcnDir char % Directory of the analysis functions.
        projectFolder char % Path to Project's Directory. Used to locate PipelineConfig and Error Log folders.
        folderPipeLog table % Pipeline LogTable stored in the "pipeLog.mat" file in the SaveFolder.
        maxLogRows = 100 % Maximum number of rows in the folderLog table. If exeeded, older entries will be erased.
        current_pipe struct % Pipeline currently running.
        current_outFile cell % List of file names created as output from some of the analysis functions.
        % It can be the name of an existing file, or "outFile" for a function
        %  that creates a file such as "run_ImagesClassification".
        h_wbItem % Handle of waitbar dialog showing the progress of the pipeline across protocol's objects.
        h_wbTask % Handle of waitbar dialog showing the progress of the pipeline in the current object.
        timeTag % timestamp used as "tag" for temporary files created during the pipeline execution.
        current_seq (1,1) {mustBeNonnegative} = 0 % index of current sequence in pipeline.
        current_seqIndx (1,1) {mustBeNonnegative} = 0 % index of step in current sequence in pipeline.
        b_pipeIsValid logical = false % TRUE, if the pipeline passed all validations and is ready to execution.
        SaveFolderList_truncated cell % Truncated version of the save folder list for better display in PipelineSummary.
    end
    
    methods
        % Constructor
        function obj = PipelineManager(SaveFolderList,varargin)
            % PIPELINEMANAGER Constructs an instance of this class
            %  Input:
            %   SaveFolderList(cell array of chars): List of Save folder
            %       paths containing .dat and .mat files.
            %   RawFolderList(cell array of chars): List of Raw folders
            %       associated with the save folders.
            %   Optionals:
            %   ProjectFolder (char): Path to "Protocol" folder. This
            %   will be used to save/load pipelines, and save pipeline
            %   error logs.
            
            p = inputParser;
            validationFun = @(x) (iscell(x) && ischar([x{:}])) || (ischar(x));
            addRequired(p,'SaveFolderList', validationFun);
            addOptional(p,'RawFolderList',{''}, validationFun);
            addOptional(p,'ProjectFolder',pwd,@ischar);
            parse(p,SaveFolderList, varargin{:});
            RawFolderList = p.Results.RawFolderList;
            obj.projectFolder = p.Results.ProjectFolder;
            clear p
            % Further validate each Item from Save and Raw folder lists.
            if ischar(SaveFolderList);SaveFolderList = {SaveFolderList};end
            if ischar(RawFolderList);RawFolderList = {RawFolderList};end
            % For the Raw Folder list, replace missing folders with
            % "MISSING" string and raise a warning. Reason: sometimes, the raw data
            % is not available (different HD, PC etc.).
            if isempty([RawFolderList{:}])
                % Default action when no RawFolderList is provided:
                RawFolderList = repmat({'MISSING'},size(SaveFolderList));
                b_rawFolderExists = false;
                warning('No Raw Folder provided. Functions that use this parameter (e.g. run_ImagesClassification) will fail!');                    
            else
                % Validate RawFolderList:
                b_rawFolderExists = isfolder(RawFolderList);
                if any(~b_rawFolderExists)
                    msg_char = repmat('\n%s',1,sum(~b_rawFolderExists));
                    warning(['The following Raw Folder(s) do not exist! Functions that use this parameter (e.g. run_ImagesClassification) will fail!' msg_char],...
                        RawFolderList{~b_rawFolderExists});
                    RawFolderList(~b_rawFolderExists) = {'MISSING'};
                end
            end
            % criterion #1 - Both lists should have the same length:
            errID = 'umIToolbox:PipelineManager:wrongInput';
            errMsg = 'Save Folder and Raw Folder lists should have the same length!';
            assert(isequaln(length(SaveFolderList),length(RawFolderList)),errID,errMsg)
            % criterion #2 - All SaveFolders should exist:
            b_SaveFolderExists = isfolder(SaveFolderList);
            msg_char = repmat('\n%s',1,sum(~b_SaveFolderExists));
            assert(all(b_SaveFolderExists), ['Operation aborted! The following Save Folder(s) do not exist:' msg_char],SaveFolderList{~b_SaveFolderExists});
            % criterion #3 - All SaveFolders should be unique:
            assert(isequaln(numel(unique(SaveFolderList)),length(SaveFolderList)),errID, 'Save Folder list cannot have duplicates!')
            % Enforce full path:
            [~,saveFolderInfo] = cellfun(@(x) fileattrib(x),SaveFolderList);
            [~,rawFolderInfo] = cellfun(@(x) fileattrib(x),RawFolderList(b_rawFolderExists));
            % Store folder lists:            
            obj.SaveFolderList = {saveFolderInfo.Name}';
            if ~isempty(rawFolderInfo)
                obj.RawFolderList = {rawFolderInfo.Name}';
            end
            % Truncate SaveFolderList
            obj.SaveFolderList_truncated = obj.truncateFolderList(obj.SaveFolderList);
            % Create timestamp tag:
            obj.timeTag = datestr(datetime('now'),'_ddmmyyyyHHMMSS');
            % Set pipeline
            obj.pipe = [];
            % Get list of available analysis functions
            if isdeployed
                [obj.fcnDir,~,~] = fileparts(which('funcTemplate.m'));
                a = load(fullfile(obj.fcnDir,'deployFcnList.mat'));
                obj.funcList = a.out; % Get the structure "out" created inside the function "umitFcnReader".
            else
                rootDir = erase(mfilename('fullpath'),['classes' filesep 'PipelineManager']);
                if isempty(rootDir)
                    error('Umitoolbox environment variable not found!')
                end
                obj.fcnDir = fullfile(rootDir, 'Analysis');
                obj.createFcnList;
            end
        end
        % SETTERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function set.pipe(obj,pipe)
            % Pipeline structure setter. If pipe is empty, create an empty
            % structure containing tasks fields.
            
            pipe_empty = struct('name','','argsIn', {},'argsOut',{},...
                'b_save2File', logical.empty, 'saveFileName','',...
                'opts',struct.empty,'opts_vals',struct.empty,...
                'opts_def',struct.empty,'inputSource','',...
                'inputStepIndx',[],'seq',[],'seqIndx',[],...
                'b_hasDataIn',false,'b_hasDataOut',false,...
                'b_hasFileOut',false,'b_paramsSet',false);% empty template for pipeline structure
            
            if ~isstruct(pipe) || isempty(fieldnames(pipe))
                pipe = pipe_empty;
            end
            % Check if all fields exist:
            if ~all(ismember(fieldnames(pipe),fieldnames(pipe_empty)))
                error('umIToolbox:PipelineManager:InvalidInput',...
                    'The pipeline structure provided is invalid!');
            end
            obj.pipe = pipe;
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function varargout = setOpts(obj,varargin)
            % SETOPTS opens an INPUTDLG for entry of optional variables
            % (OPTS) of methods in the Pipeline.
            
            p = inputParser;
            addRequired(p,'obj');
            addOptional(p,'funcName','',@ischar)
            addParameter(p,'fromSequence',obj.current_seq,@isnumeric)
            parse(p,obj, varargin{:});
            funcName = p.Results.funcName;
            seq = p.Results.fromSequence;
            state = false;
            % If pipeline is empty, abort:
            assert(~isempty(obj.pipe), 'Pipeline is empty. Create a pipeline first, then set the options!');
            % If no arguments are provided show the pipeline as a series of
            % sequences and ask input in command line:
            if any([isempty(funcName), isempty(seq)])
                fprintf('%s\nAvailable functions separated by sequence:\n',repmat('-',1,100))
                for ii = 1:obj.current_seq
                    thisSeq = obj.pipe(arrayfun(@(x) any(x.seq == ii) & numel(x.seqIndx) == 1,obj.pipe));
                    fprintf('----->> Sequence #%d :\n',ii);
                    fprintf('\t-->%s\n', thisSeq.name);
                end
            end
            if isempty(funcName)
                funcName = input('Type the name of the function to set parameters: ','s');
            end
            if isempty(seq)
                seq = input(['Type the sequence number of the function "' funcName '" :']);
            end
            % Check if the function exists in the selected pipeline sequence:
            idxName = strcmpi(funcName, {obj.pipe.name}); idxSeq = arrayfun(@(x) any(x.seq == seq),obj.pipe);
            if size(idxName,1)~= size(idxSeq,1)
                idxSeq = idxSeq';
            end
            idxFunc = idxName & idxSeq;
            if ~any(idxFunc)
                error(['The function "' funcName '" does not exist in pipeline sequence #' num2str(seq) '!']);
            end
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            
            % Check if the function has optional parameters:
            if isempty(obj.pipe(idxFunc).opts)
                disp(['The function ' obj.pipe(idxFunc).name ' does not have any optional parameters.']);
                return
            end
            
            if isfield(obj.pipe(idxFunc), 'opts_vals')
                disp('Optional parameter values found!')
                currVals = cellfun(@(x) obj.pipe(idxFunc).opts.(x),fieldnames(obj.pipe(idxFunc).opts), 'UniformOutput',false);
                defVals = cellfun(@(x) obj.pipe(idxFunc).opts_def.(x),fieldnames(obj.pipe(idxFunc).opts_def), 'UniformOutput',false);
                listVals = cellfun(@(x) obj.pipe(idxFunc).opts_vals.(x),fieldnames(obj.pipe(idxFunc).opts_vals), 'UniformOutput',false);
                typeVals = {};
                for i = 1:length(listVals)
                    if isnumeric(listVals{i}) && numel(listVals{i}) > 2
                        typeVals{i} = 'numericArray'; % Array of numerical values.
                    elseif isnumeric(listVals{i}) && numel(listVals{i}) == 2
                        typeVals{i} = 'numericRange'; % 1x2 array of numerical values indicating lower and upper bounds.
                    elseif islogical(listVals{i})
                        typeVals{i} = 'logical'; % 1x2 array of logical values = [true;false];
                    elseif all(cellfun(@ischar, listVals{i})) && numel(listVals{i}) > 1 && size(listVals{i},1) < size(listVals{i},2)
                        typeVals{i} = 'charArray'; % Cell array of strings.
                    elseif all(cellfun(@ischar, listVals{i})) && numel(listVals{i}) > 1 && size(listVals{i},1) > size(listVals{i},2)
                        typeVals{i} = 'charArrayMultiSelect'; % Cell array of strings with multi-selection option.
                    else
                        typeVals{i} = 'mixArray'; % Cell array of strings and numbers.
                    end
                end
                [out,state]= obj.buildInputDlg(obj.pipe(idxFunc).name,fieldnames(obj.pipe(idxFunc).opts),currVals,defVals,listVals,typeVals);
            end
            if isempty(out)
                state = false;
                if nargout
                    varargout{1} = state;
                end
                return
            end
            % Save parameters to 'opts' structure:
            for i = 1:numel(fieldnames(obj.pipe(idxFunc).opts))
                obj.pipe(idxFunc).opts.(out{i,1}) = out{i,2};
            end
            obj.pipe(idxFunc).b_paramsSet = true; %
            disp(['Optional Parameters set for function : ' obj.pipe(idxFunc).name]);
            if nargout
                varargout{1} = state;
            end
        end
        
        function varargout = addTask(obj,func,varargin)
            % This method adds an analysis function, or task, to the
            % pipeline. Here, we can choose to save the output of a given
            % task as a .DAT file. ADDTASK will create a string containing
            % the task that will be evaluated during pipeline execution.
            % Inputs:
            %   func (str || char):  name or index of the analysis function
            %       contained in obj.funcList property.
            %   save (bool): Optional. True means that the output data
            %       from the function will be saved as a .DAT file.
            %   saveas(char): Optional. Name of the file to be saved.
            %       If not provided, the analysis function's default
            %       filename will be used.
            %   source (char): Optional. Name of the input function OR
            %       input file. If you set this parameter, a new sequence of the
            %       pipeline will be created !
            %   sequence (numeric): Optional. Sequence number of the input
            %       function set in "inputFrom" parameter. If not provided, we
            %       assume that the function comes from the current sequence. This
            %       parameter is ignored if the input comes from the disk (e.g. a .dat file).
            % Output (optional):
            %   state (bool): FALSE, if failed to add the task to the
            %   pipeline.
            
            p = inputParser;
            addRequired(p, 'func', @(x) ischar(x) || isnumeric(x));
            addParameter(p,'save', false, @islogical);
            addParameter(p,'saveas', '', @ischar);
            addParameter(p,'source','', @(x) ischar(x) && ~strcmpi('_CURRENT_DATA_',x));
            addParameter(p,'sequence',obj.current_seq,@isPositiveIntegerValuedNumeric);
            parse(p,func, varargin{:});
            % Set optional parameters:
            b_save2File = p.Results.save;
            saveFileName = p.Results.saveas;
            inputSource = p.Results.source;
            inputFromSeq = p.Results.sequence;
            clear p
            % Set boolean flag for function execution completion:
            % Validate inputs:
            % Check if the function exists:
            idxFunc = strcmpi(func, {obj.funcList.name}); %Index of the function from the function list
            assert(any(idxFunc),['Operation aborted! The function "' func '" does not exist!']);
            % Warn the user that "sequence" cannot be set without "source":
            if ( isempty(inputSource) && inputFromSeq ~= obj.current_seq )
                warning(['Parameter "sequence" ignored. Please, set both'...
                    '"source" and "sequence" parameters to force a new sequence in the pipeline.\n"sequence" reset to #%d.'],...
                    obj.current_seq);
                % Reset to default:
                inputFromSeq = obj.current_seq;
            end
            assert(ismember(inputFromSeq,0:obj.current_seq),'The sequence "%d" doesn''t exist!',inputFromSeq);
            
            if isempty(inputSource)
                if( ~obj.funcList(idxFunc).info.b_hasDataIn && ( obj.funcList(idxFunc).info.b_hasDataOut ||  obj.funcList(idxFunc).info.b_hasFileOut ) )
                    % For functions without data as inputs that generate outputs,
                    % set input source as the save folder:
                    inputSource = '_FOLDER_'; % Set input source as the save folder.
                else
                    if isempty(obj.pipe) && obj.b_inputFromDataViewer
                        inputSource = '_DATAVIEWER_';
                    else                        
                        % Set default value to inputSource (data in RAM)
                        inputSource = '_CURRENT_DATA_';
                    end
                end
                % Default behaviour ( function added to the current sequence)
                % Raise error if the function already exists:
                assert(~ismember(func,{obj.pipe(arrayfun(@(x) any(x.seq == (obj.current_seq)),obj.pipe)).name}),...
                    ['Operation aborted! The function "' func '" already exists in the current sequence.'...
                    ' To force the creation of a new sequence, set the "source" and "sequence" parameters.']);
            end
            % Create "task" structure. This is the one that will be added
            % to the pipeline:
            task = obj.funcList(idxFunc).info;
            % Remove extra fields:
            extra_fields = setdiff(fieldnames(task),fieldnames(obj.pipe));
            task = rmfield(task,extra_fields);
            task.name = obj.funcList(idxFunc).name;
            % Add default values for fields used to save the data: These
            % values will be updated later:
            task.b_save2File = b_save2File | ~isempty(saveFileName);
            task.saveFileName = saveFileName;
            task.b_paramsSet = false;
            % Update saving info:
            task = obj.setSaveFilename(task,false);
            % Manage inputs
            task = obj.setInput(task,inputSource,inputFromSeq);
            if isempty(task)
                % User cancelled during "setInput" method.
                state = false;
            else
                state = true;
                % Finally, add task to pipeline:
                obj.pipe = [obj.pipe; task];
                fprintf('Added "%s" to sequence #%d of the pipeline.\n',task.name, obj.current_seq)
            end
            % Output flag
            if nargout
                varargout{1}= state;
            end
            
        end
        
        function varargout = rmTask(obj,func2Del,varargin)
            % RMTASK removes a given function from the existing pipeline and
            % updates the remaining steps in order to maintain the pipeline
            % workflow.
            % Inputs:
            %   func2Del (str):  name of the analysis function from the
            %       pipeline to be deleted
            %   Optional:
            %       fromSequence (num scalar): index of the sequence containing
            %           the function to be deleted. If not provided, the current
            %           sequence will be used.
            % Outputs (optional):
            %   state (bool): FALSE, if failed to remove the task from the
            %       pipeline.
            
            p = inputParser;
            addRequired(p,'func2Del',@(x) ischar(x) || isnumeric(x));
            addParameter(p,'fromSequence',obj.current_seq,@isPositiveIntegerValuedNumeric);
            parse(p,func2Del,varargin{:});
            fromSeq = p.Results.fromSequence;
            if isempty(obj.pipe)
                warning('Operation aborted. The pipeline is already empty.')
                return
            end
            
            % Check if the function exists in the pipeline sequence:
            idxFunc = ( strcmpi(func2Del,{obj.pipe.name}) & ...
                arrayfun(@(x) any(x.seq == fromSeq),obj.pipe)' );
            assert(any(idxFunc),...
                'Operation aborted! The function "%s" does not exist in sequence #%d!',...
                func2Del,fromSeq);
            % Get task to be removed:
            stepToDelete = obj.pipe(idxFunc);
            % Store original pipeline and indices:
            original_pipe = obj.pipe;
            original_seq = obj.current_seq;
            original_seqIndx = obj.current_seqIndx;
            state = true;
            % Delete step from pipeline:
            
            % #1 - Easiest case: There is only one step:
            if length(obj.pipe) == 1
                obj.reset_pipe;
                fprintf('Function "%s" removed from the pipeline.\n',stepToDelete.name);
                if nargout; varargout{1} = state;end
                return
            end
            
            % #2 - The more complex situation: There are one or more sequences
            % that stem from the step to be deleted. Here, we manage the
            % inputs and sequence indices following the deletion of the
            % step from the pipeline:
            
            % Get step's sequence up to the one to be deleted:
            prev_steps = obj.pipe(1:find(idxFunc) - 1); % Previous steps.
            % Identify steps that branch out from the step to be deleted:
            next_steps = obj.pipe(find(idxFunc) + 1:end);
            % Reset sequence and indices to the last step prior to the
            % one to be deleted.
            obj.pipe = prev_steps;
            if ~isempty(obj.pipe)
                obj.current_seq = prev_steps(end).seq;
                obj.current_seqIndx = prev_steps(end).seqIndx;
            else
                obj.current_seq = 0;
                obj.current_seqIndx = 0;
            end
            % Loop across each step and re-assing the inputs:
            state = true;
            for ii = 1:length(next_steps)
                sourceFile = '';
                % Set input index for the current step:
                if next_steps(ii).inputStepIndx && isequaln(original_pipe(next_steps(ii).inputStepIndx), stepToDelete)
                    % The input step is the one to be deleted. In this
                    % case, we skip it to input from the latter.
                    inputStepIndx = stepToDelete.inputStepIndx;
                else
                    inputStepIndx = next_steps(ii).inputStepIndx;
                end
                
                % Manage input Source for the current step. If the input source is the folder,stop looking up the pipeline.
                if ~inputStepIndx
                    % When the input source is the FOLDER:
                    if ~strcmpi(next_steps(ii).inputSource, '_CURRENT_DATA_') && next_steps(ii).inputStepIndx
                        % Force Input Dialog to select File from folder
                        inputSource = '_FOLDER_';
                    else
                        inputSource = next_steps(ii).inputSource;
                    end
                    % Force new sequence:
                    inputSeqIndx = 0;
                else
                    % When the input source is a function from the
                    % pipeline:
                    if original_pipe(inputStepIndx).b_hasDataOut && next_steps(ii).seq == original_pipe(inputStepIndx).seq
                        % If the input function outputs data, set the input
                        % source as "_CURRENT_DATA_".
                        inputSource = '_CURRENT_DATA_';
                        % Keep the current sequence:
                        inputSeqIndx = obj.current_seq;
                    elseif (original_pipe(inputStepIndx).b_hasDataOut && next_steps(ii).seq ~= original_pipe(inputStepIndx).seq) || original_pipe(inputStepIndx).b_hasFileOut
                        % If the input function output files, check if the
                        % file was already set. Otherwise, let 'setInput'
                        % manage.
                        inputSource = original_pipe(inputStepIndx).name;
                        sourceFile = next_steps(ii).inputSource;
                        
                        idxOrig = strcmp(inputSource,{original_pipe.name}) & ~idxFunc;
                        
                        origSourceFcnRelPos = zeros(size(idxOrig));
                        origSourceFcnRelPos(idxOrig) = 1:sum(idxOrig);
                        
                        idxNew = strcmp(inputSource,{obj.pipe.name});
                        newSourceFcnRelPos = zeros(size(idxNew));
                        newSourceFcnRelPos(idxNew) = 1:sum(idxNew);
                        
                        inputSeqIndx = obj.pipe(newSourceFcnRelPos == origSourceFcnRelPos(next_steps(ii).inputStepIndx)).seq;
                    else
                        % Default to folder:
                        inputSource = '_FOLDER_';
                    end
                end
                
                try
                    task = obj.setInput(next_steps(ii),inputSource,inputSeqIndx,sourceFile);
                catch ME
                    disp(next_steps(ii));
                    disp(inputSource)
                    task = [];
                    fprintf('FAILED TO REMOVE "%s"! ERROR OCCURRED:\n%s',stepToDelete.name,getReport(ME));
                end
                
                if isempty(task)
                    % User cancelled.
                    state = false;
                    break
                end
                obj.pipe = [obj.pipe;task];
            end
            
            if ~state
                obj.pipe = original_pipe;
                obj.current_seq = original_seq;
                obj.current_seqIndx = original_seqIndx;
                fprintf('Operation Failed! Restored pipeline to original.\n')
                
            else
                fprintf('Function "%s" removed from the pipeline.\n',stepToDelete.name);
            end
            
            if nargout; varargout{1} = state;end
            
        end
        %%%%% -------------------------------------------------------------
        function varargout = showPipeSummary(obj)
            % This method creates a summary of the current pipeline.
            
            % Output (optional): if an output variable exists, it creates a
            % character array, if not, the information is displayed in the
            % command window.
            
            if isempty(obj.pipe)
                disp('Pipeline is empty!')
                if nargout;varargout{1} = '';end
                return
            end
            
            str = sprintf('Pipeline Summary:\n\n');
            for i = 1:length(obj.pipe)
                str =  [str sprintf('--->> Step # %d (sequence #%d) <<---\n', i,obj.pipe(i).seq)]; %#ok
                str = [str,sprintf('Function name: "%s"\n%s\n--------------------\n',...
                    obj.pipe(i).name,obj.genToolTipTxt(obj.pipe(i)))];   %#ok
            end
            if nargout == 0
                disp(str)
            else
                varargout{1} = str;
            end
        end
        
        function showFuncList(obj)
            % Displays a list of analysis function from "obj.funcList" in
            % the command window.
            disp('List of available functions (Caterogy):');            
            folderList = erase(obj.truncateFolderList({obj.funcList.folder}),['...' filesep]);
            for i = 1:length(obj.funcList)
                fprintf('%d : %s (%s)\n', i, obj.funcList(i).name, folderList{i});
            end
        end
        
        function run_pipeline(obj)
            % RUN_PIPELINE runs the tasks in OBJ.PIPE
            
            if isempty(obj.pipe)
                fprintf('Pipeline is empty!\n');
                return
            end
            
            % Reset PipelineSummary table:
            obj.PipelineSummary = table();
            % Force saving sequences' last steps (Except for DataViewer)
            obj.forceSaveLastStep; % Run pipeline validation
            
            % Initialize waitbars:
            obj.setWaitBar('Initialize')
            
            for ii = 1:length(obj.SaveFolderList)
                % Reset pipeline working copy:
                obj.pipe_session = obj.pipe;
                % Clear current data, metaData and File List for each item in te pipeline:
                if ~obj.b_inputFromDataViewer
                    obj.current_data = []; obj.current_info = []; obj.current_outFile = {};
                end
                obj.b_state = true;
                % Update current save and raw folders:
                obj.current_saveFolder = obj.SaveFolderList{ii};
                obj.current_rawFolder = obj.RawFolderList{ii};
                obj.loadPipeLog(obj.SaveFolderList{ii});
                % Update Data History from current save folder:
                obj.loadDataHistory(obj.current_saveFolder);
                
                % Update waitbars:
                obj.setWaitBar('UpdateItem', ii, length(obj.SaveFolderList));
                fprintf([repmat('-',1,50),'\n']);
                fprintf('Save Folder : %s\n', obj.current_saveFolder);
                fprintf('Raw Folder : %s\n', obj.current_rawFolder);
                % Run one sequence at a time:
                for jj = 1:max([obj.pipe_session.seq],[],'all')
                    obj.current_seq = jj;
                    % Get current pipeline sequence:
                    thisSeq = obj.pipe_session([obj.pipe_session.seq] == obj.current_seq);
                    [newSeq, skippedSteps,~] = obj.skipSteps(thisSeq);
                    if ~isempty(skippedSteps)
                        if isequaln(skippedSteps,thisSeq)
                            % When all sequence is skipped:
                            fprintf('All steps skipped from sequence # %d. The following file contains the whole sequence:\n',thisSeq.seq)
                            fprintf('\t"%s"\n',newSeq.inputSource);
                            newSeq.runDatetime = datetime('now');
                            % Add to log:
                            obj.updatePipeLog(newSeq,true,'Sequence Skipped');
                            % Go to next sequence:
                            continue
                        else
                            % When some steps are skipped:
                            fprintf('The following steps will be skipped:\n')
                            fprintf('\t"%s"\n',skippedSteps.name);
                            % Update current sequence:
                            thisSeq = newSeq;
                        end
                    end
                    
                    % Run each step for the current sequence:
                    for kk = 1:length(thisSeq)
                        %
                        obj.setWaitBar('UpdateTask', kk/length(thisSeq),'taskName',thisSeq(kk).name);
                        fprintf('Running task # %d/%d (Sequence #%d) ----->>>>>\n',kk,length(thisSeq),thisSeq.seq);
                        % Execute step on target object:
                        obj.run_taskOnTarget(thisSeq(kk));
                        % Control for Pipeline cancelling by User:
                        if getappdata(obj.h_wbItem, 'b_abortPipe')
                            % Delete waitbars and abort inner loop:
                            delete([obj.h_wbItem, obj.h_wbTask])
                            break
                        end
                        % If execution failed, abort.
                        if ~obj.b_state
                            break
                        end
                        % This pause is here to allow the WaitBar to update
                        % during the execution of this method.
                        pause(.001);
                    end
                    fprintf([repmat('-',1,50),'\n']);
                    % Remove temporary files with appended with the "timeTag":
                    obj.deleteTemporaryFiles(obj.current_saveFolder);
                    % Abort outer loop if user cancels pipeline or a pipeline execution failed:
                    if ~ishandle(obj.h_wbItem) || ~obj.b_state
                        break
                    end
                end
                % Abort outer loop if user cancels pipeline:
                if ~ishandle(obj.h_wbItem)
                    break
                end
                % Save folderLog file:
                obj.savePipeLog(obj.current_saveFolder);
            end
            
            % Show Pipeline Summary in command window:
            disp(obj.PipelineSummary);
            % Delete progress bars:
            delete([obj.h_wbItem, obj.h_wbTask]);
            % Request User permission to save error report:
            obj.genErrorReport;
        end
        
        function savePipe(obj,varargin)
            % SAVEPIPE saves the structure OBJ.PIPE in a .PIPE file in the
            % folder PIPELINECONFIGFILES inside the SAVEDIR of OBJ.PROTOCOLOBJ.
            % If this function is called from DataViewer, it saves in
            % DataViewer's folder set by the user.
            p = inputParser;
            addRequired(p,'obj');
            addOptional(p,'pipeFile',fullfile(pwd,'MyPipeline.pipe'),@ischar);
            parse(p,obj,varargin{:});
            pipeFile = p.Results.pipeFile;
            
            % Ensure that all sequences are saved.
            obj.forceSaveLastStep;
            % Parse file name to enforce the right extension:
            [path, filename,ext] = fileparts(pipeFile);
            if ~strcmpi(filename,'.pipe') || isempty(ext)
                ext = '.pipe'; % Enforce extension.
            end
            % If the user did not set a path, use ProjectFolder:
            if isempty(path)
                if ~obj.b_inputFromDataViewer
                    path = fullfile(obj.projectFolder, 'PipeLineConfigFiles');
                    [~,~] = mkdir(path);
                else
                    path = obj.projectFolder;
                end
            end
            pipeStruct = obj.pipe;
            % Save:
            save(fullfile(path,[filename ext]), 'pipeStruct','-mat');
            fprintf('Pipeline saved as "%s" in folder "%s".\n',[filename ext],path);
        end
        
        function loadPipe(obj,varargin)
            % LOADPIPE loads the structure PIPE inside FILENAME and assigns
            % it to OBJ.PIPE property.
            % Input:
            %   pipeFile(char): full path to the .JSON file containing the
            %   pipeline config.
            p = inputParser;
            addRequired(p,'obj');
            addOptional(p,'pipeFile',fullfile(pwd,'MyPipeline.pipe'),@ischar);
            parse(p,obj,varargin{:});
            pipeFile = p.Results.pipeFile;
            %
            assert(isfile(pipeFile),'The file "%s" doesn''t exist!',pipeFile);
            % Read Pipeline Config file:
            a = load(pipeFile,'-mat');
            new_pipe = a.pipeStruct;
            % Reset current pipeline:
            obj.reset_pipe;
            % Check if all functions listed in "new_pipe" exist:
            idx = ismember({new_pipe.name},{obj.funcList.name});
            if ~all(idx)
                h = errordlg(['The following functions do not exist:' sprintf('\n"%s"',new_pipe(~idx).name)], ...
                    'Failed to load pipeline!');
                waitfor(h);
                return
            end
            obj.pipe = new_pipe;
            % Update current sequence indices:
            obj.current_seq = max([obj.pipe.seq],[],'all');
            obj.current_seqIndx = max([obj.pipe([obj.pipe.seq] == obj.current_seq).seqIndx],[],'all');
            fprintf('Pipeline loaded from "%s"\n',pipeFile);
            % Check if all sequences are saved:
            obj.forceSaveLastStep;
        end
        
        function reset_pipe(obj)
            % This function erases the pipe property and resets the funcList
            % property to default parameter values.
            obj.pipe = struct();
            % Reset some properties:
            if ~obj.b_inputFromDataViewer
                obj.current_data = [];
            end
            obj.current_outFile = {};
            obj.current_seq = 0; obj.current_seqIndx = 0;
            obj.b_pipeIsValid = false;
            %
            disp('Pipeline reset!')
        end
        
        function generateScript(obj, filename)
            %   GENERATESCRIPT Generates a MATLAB script file from the pipeline structure.
            %   Generates a script file that executes the steps defined in the pipeline.
            %
            %   Input:
            %   - filename: The name of the script file to be generated.
            %
            %   This method iterates through the pipeline steps, generates MATLAB script
            %   code for each step, and appends it to the output script file specified
            %   by 'filename'. The script includes loading input data (if required),
            %   setting optional parameters, executing the pipeline step function,
            %   and saving output data to files (if required). Additionally, it may
            %   include a section to delete temporary files.
            %
            
            % Check if the pipeline is empty, and if so, return.
            if isempty(obj.pipe)
                return
            end
            
            % Ensure that all sequences are saved:
            obj.forceSaveLastStep;
            
            % Create the initial text for the script.
            txt = sprintf(['%%%% Pipeline script.\n%% Script generated by PipelineManager class @'...
                '%s\n\n%% clearvars;%% Clear workspace (commented by default)\n%%'...
                'Here is a summary of the pipeline:\n'], datestr(now(), 'HH:MM:ss dd-mm-yyyy'));
            % Add pipeline summary to script docstring:
            summaryTxt = '';
            tmp = obj.showPipeSummary;
            idxNL = 1+regexp(tmp,'\n');
            idxNL = [1 idxNL(1:end-1)];
            for ii = 2:length(idxNL)
                summaryTxt = [summaryTxt  sprintf('%%\t\t') tmp(idxNL(ii-1):idxNL(ii)-1)];%#ok
            end
            txt = [txt summaryTxt];
            % Initialize working folder to the current directory.
            txt = [txt sprintf('%%%% Set variables:\nRawFolder = pwd; %% By Default, set the current folder as the working folder.\nSaveFolder = pwd;\n%%%% Pipeline execution\n\n')];
            
            % Loop through each step in the pipeline.
            curSeq = 0;
            for ii = 1:length(obj.pipe)
                if obj.pipe(ii).seq(1) ~= curSeq
                    txt = [txt sprintf('%% Sequence %d:\n',obj.pipe(ii).seq(1))];
                    curSeq = obj.pipe(ii).seq(1);
                end
                % Generate comments for the current step.
                txt = [txt sprintf('%% Execute "%s":\ndisp(''[Running...] %s'');\n', obj.pipe(ii).name,obj.pipe(ii).name)];%#ok
                
                % Add data loading string if input data file is specified.
                if endsWith(obj.pipe(ii).inputSource,'.dat') || endsWith(obj.pipe(ii).inputSource,'.datstat')
                    txt = [txt sprintf('data = loadData(''%s''); %% Load input data\n', obj.pipe(ii).inputSource)];%#ok
                end
                
                % Set input and output argument names.
                argsIn = obj.pipe(ii).argsIn;
                argsIn(strcmpi(argsIn,'object')) = [];
                
                % Add optional parameters if applicable.
                optsStr = '';
                fcnStr = '';
                if obj.pipe(ii).b_paramsSet
                    fn = fieldnames(obj.pipe(ii).opts);
                    for jj = 1:length(fn)
                        if ischar(obj.pipe(ii).opts.(fn{jj}))
                            val = ['''' obj.pipe(ii).opts.(fn{jj}) ''''];
                        elseif iscell(obj.pipe(ii).opts.(fn{jj})) && ischar([obj.pipe(ii).opts.(fn{jj}){:}])
                            val = '{{';
                            for kk = 1:length(obj.pipe(ii).opts.(fn{jj}))
                                val = [val '''' obj.pipe(ii).opts.(fn{jj}){kk} '''', ','];
                            end
                            val(end:end+1) = '}}';
                        else
                            val = ['[' strjoin(arrayfun(@num2str, obj.pipe(ii).opts.(fn{jj}), 'UniformOutput', false), ';') ']'];
                        end
                        optsStr = [optsStr ',''' fn{jj} ''',' val];
                    end
                    optsStr = ['opts = struct(' strip(optsStr, 'left', ',') '); % Optional parameters'];
                else
                    argsIn(strcmpi(argsIn,'opts')) = [];
                end
                
                argsOut = obj.pipe(ii).argsOut;
                argsOut = replace(argsOut, 'outData', 'data');
                
                % Create function string for the current step.
                if isempty(argsOut)
                    fcnStr = [fcnStr ';' obj.pipe(ii).name '(' strjoin(argsIn, ',') ');'];%#ok
                elseif numel(argsOut) == 1
                    fcnStr = [fcnStr ';' strjoin(argsOut, ',') ' = ' obj.pipe(ii).name '(' strjoin(argsIn, ',') ');'];%#ok
                else
                    fcnStr = [fcnStr ';' '[' strjoin(argsOut, ',') '] = ' obj.pipe(ii).name '(' strjoin(argsIn, ',') ');'];%#ok
                end
                fcnStr = strip(fcnStr, 'left', ';');
                txt = [txt sprintf('%s\n%s\n\n', optsStr, fcnStr)];%#ok
                
                % File Saving section:
                if obj.pipe(ii).b_save2File
                    % Save data to file.
                    txt = [txt sprintf('saveData(fullfile(SaveFolder, ''%s''), data); %% Save data to .DAT file "%s" \n', obj.pipe(ii).saveFileName, obj.pipe(ii).saveFileName)];%#ok
                end
                txt = [txt sprintf('disp(''[Completed] %s'');\n',obj.pipe(ii).name)];
            end
            
            % Special case:
            % Create a section to delete temporary files created inside the script.
            idx = cellfun(@(x) startsWith(x,'tmpFile_'),{obj.pipe.saveFileName});
            if any(idx)
                % Create deletion section.
                delStr = sprintf('%%%% Delete temporary files\n%% Delete .dat/mat files created during the execution of this script.\n');
                delStr  = [delStr sprintf('disp(''Deleting temporary files...'');\n')];
                fNames = {obj.pipe.saveFileName};
                fNames(~idx) = [];
                for ii = 1:length(fNames)
                    delStr = [delStr sprintf('delete(''%s'');\n', fNames{ii})];%#ok
                end
                txt = [txt delStr];
            end
            
            % Add a closing comment to the script.
            txt = [txt sprintf('%%%%\ndisp(''Script execution completed!'');\n%%%%%%%%%%%%%%%%%%%%%%%% END OF FILE %%%%%%%%%%%%%%%%%%%%%%%%')];
            
            % Save the generated script text to the specified file.
            [folder,file,~] = fileparts(filename);
            if isempty(folder);folder = pwd;end
            filename = fullfile(folder,[file '.m']);
            fid = fopen(filename, 'w');
            fprintf(fid, '%s', txt);
            fclose(fid);
                      
            % Display a message indicating that the script has been generated.
            disp('Script generated!')                                    
            % Open the folder containing the generated script.
            openFolder(folder);
        end
        %%%%%%--Pipeline Visualization  -----------------------------------
        function varargout = drawPipe(obj)
            % DRAWPIPE creates a graphical representation of the pipeline.
            % The user is able to click on buttons to set parameters, save
            % files and visualize the function's info.
            % Output:
            %   fH (handle): handle to the figure with the pipeline graph.
            
            % Abort if the pipeline is empty.
            varargout = {};
            if isempty(obj.pipe)
                disp('Pipeline is empty!')
                if nargout; varargout = {[]};end
                return
            end
            % Delete any existing pipeline Figure;
            delete(findall(0,'Tag','ThisPipelineGraph'));
            
            % Create local copy of the pipeline. We will change some info
            % just for the sake of plotting.
            pp = obj.pipe;
            % Make some variables available to local functions:
            myGreen = [];
            % Set GUI elements' parameters:
            BackgroundColor = [.94 .94 .94]; % Figure's background color.
            % Containers:
            Container.Units = 'pixels';
            Container.Margin = 10;% Container's internal margins (in pixels).
            
            % Buttons:
            buttonParams.Units = 'pixels';
            buttonParams.xSpacing = 20;
            buttonParams.ySpacing = 60;
            buttonParams.height = 35;
            buttonParams.FontSize = 11;
            buttonParams.Color.Red = [.9 0 0];
            buttonParams.Color.Green= [0 .85 0];
            buttonParams.Color.Gray = [.92 .92 .92];
            % Arrows:
            arrowParams.Units = 'pixels';
            arrowParams.LineWidth= 1;
            arrowParams.HeadWidth = 9;
            arrowParams.FontSize = 8;
            % Create figure when no axis is provided:
            fH = figure('Name','Pipeline Visualization',...
                'Color',BackgroundColor,...
                'MenuBar','none',...
                'Toolbar','none',...
                'NumberTitle','off',...
                'Units',Container.Units,...
                'HandleVisibility','callback',...
                'Visible','on','Tag','ThisPipelineGraph');
            
            % Create panel to be able to lock the figure during PushButton
            % Callback execution:
            pan = uipanel('Parent', fH, 'Position',[0 0 1 1], 'Title','Setting parameter...','Visible','off','BackgroundColor',BackgroundColor);
            
            % Create UIContext Menu for extra options:
            cm = uicontextmenu(fH);
            uimenu('Parent',cm,'Label','Save to file','Callback',{@chooseSaveFileName,obj}); % Menu to change save filename.
            uimenu('Parent',cm,'Label','Undo saving','Callback',{@chooseSaveFileName,obj});
            % Set container:
            Container.handle = fH;
            
            % Create all buttons and resize the Container:
            [btnArr, sourceBtn] = createButtons;
            % Create arrows linking buttons:
            createArrows;
            
            uistack(pan, 'top');
            if nargout
                varargout{1} = fH;
            end
            %%%%% Local functions and Callbacks----------------------------
            
            function [btnArr, sourceBtn] = createButtons
                % Create buttons for each function:
                % The buttons will be repositionned later.
                if obj.b_inputFromDataViewer
                    sourceBtnString = 'DataViewer';
                else
                    sourceBtnString = 'Folder';
                end
                % Set empty cell array for source buttons.
                sourceBtn = uicontrol(Container.handle,'Style','pushbutton',...
                    'String',sourceBtnString,...
                    'BackgroundColor',BackgroundColor,...
                    'FontSize',buttonParams.FontSize,...
                    'UserData',0,...
                    'Enable','inactive');
                sourceBtn.Position(3) = sourceBtn.Extent(3)+25;
                for ii = 1:length(pp)
                    % Create function buttons:
                    btnArr(ii) = uicontrol(Container.handle,'Style','pushbutton',...
                        'String',pp(ii).name,...
                        'FontSize',buttonParams.FontSize,...
                        'UserData',ii,...
                        'Callback',{@callSetOpts,obj,pan},...
                        'Units',buttonParams.Units,...
                        'BackgroundColor',BackgroundColor);
                    % Update button dimension to avoid word wrapping:
                    btnArr(ii).Position(3) = btnArr(ii).Extent(3)+25;
                    if pp(ii).b_hasDataOut
                        % Add context menu for functions with output data. This
                        % will be used to allow the user to set the save file
                        % name.
                        btnArr(ii).UIContextMenu = cm;
                    end
                    % Add tooltip with function's information:
                    btnArr(ii).Tooltip = obj.genToolTipTxt(pp(ii));
                end
                % Make all buttons the same width
                maxW = max([arrayfun(@(x) x.Position(3), btnArr), sourceBtn.Position(3)]);
                % Create X and Y positions for each button:
                % Also, calculate new figure width and height:
                nRows = 1 + max([pp.seqIndx]);
                nCols = max([pp.seq]);
                xPosition = Container.Margin + [0:nCols-1].*(maxW + buttonParams.xSpacing);
                newContainerWidth = xPosition(end) + maxW + Container.Margin;
                
                yPosition = Container.Margin + buttonParams.height + [0:nRows-1].*(buttonParams.height + buttonParams.ySpacing);
                newContainerHeight = yPosition(end) + Container.Margin;
                yPosition = newContainerHeight - yPosition;
                % Resize container:
                Container.handle.Position([3 4]) = [newContainerWidth, newContainerHeight];
                
                % Place function buttons:
                for ii = 1:length(btnArr)
                    set(btnArr(ii),'Position',[xPosition(pp(btnArr(ii).UserData).seq), yPosition(1+pp(btnArr(ii).UserData).seqIndx), maxW, buttonParams.height]);
                end
                
                % Place source button in the middle of the figure
                set(sourceBtn,'Position',[mean(xPosition), yPosition(1), maxW, buttonParams.height]);
                
                % Change buttons appearance:
                myGreen = prettyfyButtons(btnArr,buttonParams,BackgroundColor);
                
            end
            
            function callSetOpts(src,~,obj,panel)
                % This callback calls the method "setOpts" and changes the
                % color of the button when parameters were changed.
                
                % Get pipeline index:
                ppIndx = src.UserData;
                step = obj.pipe(ppIndx);
                if isempty(step.opts)
                    % Abort, if no parameters exist
                    return
                end
                % Block figure interaction by turning uipanel visible
                panel.Visible = 'on';
                % Call "setOpts"
                state = obj.setOpts(step.name, 'fromSequence',step.seq);
                if state
                    % Update button's tooltip text:
                    src.Tooltip = obj.genToolTipTxt(obj.pipe(ppIndx));
                    % Change the button color to green:
                    src.CData = myGreen;
                    jiggleFig(ancestor(src, 'figure')) % Update tooltips
                end
                % Show figure content
                panel.Visible = 'off';
            end
            
            function createArrows
                % Creates arrows linking all buttons.]
                
                % Draw arrows from individual sequences first:
                sequenceList = unique([obj.pipe.seq]);
                for ii = 1:length(sequenceList)
                    this_seq = obj.pipe([obj.pipe.seq] == sequenceList(ii));
                    % Find source button:
                    for jj = 1:length(this_seq)
                        txt ='';
                        indxStep = find(arrayfun(@(x) isequaln(this_seq(jj),x),obj.pipe));
                        % Find target button:
                        target = btnArr(indxStep);
                        %                         if ~strcmpi(this_seq(jj).inputSource,'_CURRENT_DATA_') && ~this_seq(jj).inputStepIndx
                        if ~this_seq(jj).inputStepIndx
                            % Source is a file/folder.
                            source = sourceBtn;
                            % Set direction
                            if source.Position(1) == target.Position(1)
                                dir = 'down';
                            else
                                dir = 'downFromSource';
                            end
                            if strcmpi(this_seq(jj).inputSource,'_FOLDER_') || strcmpi(this_seq(jj).inputSource,'_CURRENT_DATA_')
                                txt = '';                                
                            else
                                txt = this_seq(jj).inputSource;
                            end
                            
                        elseif obj.pipe(indxStep).inputStepIndx
                            % Source is another function
                            source = btnArr(obj.pipe(indxStep).inputStepIndx);
                            % Set direction
                            if obj.pipe(source.UserData).seq ~= this_seq(jj).seq
                                dir = 'up';
                            else
                                dir = 'down';
                            end
                            % Set text:
                            if ~(strcmpi(this_seq(jj).inputSource, '_CURRENT_DATA_') || startsWith(this_seq(jj).inputSource,'tmpFile_'))
                                % The source function outputs a file.
                                txt = this_seq(jj).inputSource;
                            end
                            
                        else
                            % Skip steps without inputs or outputs (DEV: FOR
                            % NOW...)
                            continue
                        end
                        % Draw linking arrows:
                        drawSingleArrow(source,target,dir,txt, buttonParams.xSpacing,buttonParams.ySpacing,arrowParams);
                        % Draw save arrow:
                        if obj.pipe(target.UserData).b_save2File
                            drawSaveArrow(target);
                        end
                    end
                end
            end
            
            function drawSingleArrow(sourceBtn,targetBtn,direction,text,xSpacing, ySpacing, arrowParams)
                % Draws a single arrow between two buttons.
                buttonWidth = sourceBtn.Position(3);
                buttonHeight = sourceBtn.Position(4);
                % Check if source and target are in the same column
                switch lower(direction)
                    case 'down'
                        % Source and target are in the same column:
                        
                        % Draw a single arrow from the bottom of the source to
                        % the top of the target:
                        x = [sourceBtn.Position(1) + buttonWidth/2, sourceBtn.Position(1) + buttonWidth/2];
                        y = [sourceBtn.Position(2), targetBtn.Position(2) + buttonHeight];
                    case 'downfromsource'
                        % Draws line segments from FOLDER button with target at a different column.
                        x = [sourceBtn.Position(1) + buttonWidth/2, sourceBtn.Position(1) + buttonWidth/2;...
                            sourceBtn.Position(1) + buttonWidth/2, targetBtn.Position(1) + buttonWidth/2;...
                            targetBtn.Position(1) + buttonWidth/2, targetBtn.Position(1) + buttonWidth/2];
                        y = [sourceBtn.Position(2), sourceBtn.Position(2) - ySpacing/3;...
                            sourceBtn.Position(2) - ySpacing/3,sourceBtn.Position(2) - ySpacing/3;...
                            sourceBtn.Position(2) - ySpacing/3, targetBtn.Position(2) + buttonHeight];
                    otherwise
                        % Set X positions for all line segments
                        x = [sourceBtn.Position(1) + buttonWidth, sourceBtn.Position(1) + buttonWidth + xSpacing/2;...
                            sourceBtn.Position(1) + buttonWidth + xSpacing/2,sourceBtn.Position(1) + buttonWidth + xSpacing/2;...
                            sourceBtn.Position(1) + buttonWidth + xSpacing/2, targetBtn.Position(1) - xSpacing/2;...
                            targetBtn.Position(1) - xSpacing/2, targetBtn.Position(1) - xSpacing/2;...
                            targetBtn.Position(1) - xSpacing/2, targetBtn.Position(1) + buttonWidth/2;...
                            targetBtn.Position(1) + buttonWidth/2, targetBtn.Position(1) + buttonWidth/2];
                        
                        y = [sourceBtn.Position(2) + buttonHeight/2, sourceBtn.Position(2) + buttonHeight/2;...
                            sourceBtn.Position(2) + buttonHeight/2, sourceBtn.Position(2) + buttonHeight + ySpacing/2;...
                            sourceBtn.Position(2) + buttonHeight + ySpacing/2, sourceBtn.Position(2) + buttonHeight + ySpacing/2;...
                            sourceBtn.Position(2) + buttonHeight + ySpacing/2, targetBtn.Position(2) + buttonHeight + ySpacing/2;...
                            targetBtn.Position(2) + buttonHeight + ySpacing/2, targetBtn.Position(2) + buttonHeight + ySpacing/2;...
                            targetBtn.Position(2) + buttonHeight + ySpacing/2, targetBtn.Position(2) + buttonHeight];
                end
                
                for ind = 1:size(x,1)
                    if ind == size(x,1)
                        if isempty(text)
                            % Simple arrow:
                            an = annotation(Container.handle,'arrow',[0,0],[1,1],...
                                'Units',arrowParams.Units,...
                                'LineWidth',arrowParams.LineWidth,...
                                'HeadWidth',arrowParams.HeadWidth);
                            % Update coordinates once Units are set:
                            set(an,'X',x(ind,:),'Y',y(ind,:));
                        else
                            an = annotation(Container.handle, 'textArrow',[0,0],[1,1],...
                                'Units',arrowParams.Units,...
                                'HeadWidth',arrowParams.HeadWidth,...
                                'LineWidth',arrowParams.LineWidth,...
                                'String',text,...
                                'Interpreter','none',...
                                'FontSize',arrowParams.FontSize,...
                                'VerticalAlignment','top',...
                                'TextBackgroundColor',[1 1 1],...
                                'HorizontalAlignment','center');
                            set(an,'X',x(ind,:),'Y',y(ind,:));
                        end
                    else
                        % Draw a line:
                        an = annotation(Container.handle, 'line',[0,0],[1,1],...
                            'Units',arrowParams.Units,...
                            'LineWidth',arrowParams.LineWidth);
                        set(an,'X',x(ind,:),'Y',y(ind,:));
                    end
                end
                
            end
            
            function drawSaveArrow(btn)
                % Draw a magenta arrow next to the button to indicate that
                % the data output will be saved to a .dat file.
                saveArrow = annotation(Container.handle,'arrow',[0,0],[1,1],...
                    'Units',arrowParams.Units,...
                    'HeadStyle','cback1',...
                    'LineWidth',arrowParams.LineWidth,...
                    'Color',[1 0 1],...
                    'Tag','saveArrow',...
                    'UserData',btn.UserData,...
                    'HeadWidth',arrowParams.HeadWidth);
                
                % Update coordinates once Units are set:
                x = [btn.Position(1) + btn.Position(3) + 5,btn.Position(1) + btn.Position(3) + 5];
                y = [btn.Position(2) + buttonParams.height, btn.Position(2) ];
                set(saveArrow,'X',x,'Y',y);
            end
            
            function jiggleFig(figH)
                % For some reason, the tooltip doesn't update until we
                % resize the figure...
                figH.Position(3) = figH.Position(3) + 1;
                figH.Position(3) = figH.Position(3) - 1;
            end
            
            function [Green, Red, Gray] = prettyfyButtons(buttonArray, Params, bcgColor)%#ok
                
                btnSz = buttonArray(1).Position([3 4]);
                w = round(btnSz(1)); % width
                h = round(btnSz(2)); % height
                % Choose the radius of the rounded corners
                r = round(.05*w); % radius
                % Define the x and y grids using meshgrid
                [x, y] = meshgrid(1:w, 1:h);
                % Define a mask for the rounded rectangle
                mask = ((x <= r) & (y <= r) & (sqrt((x - r).^2 + (y - r).^2)) <= r) | ... % top left corner
                    ((x >= w - r) & (y <= r) & (sqrt((x - w + r).^2 + (y - r).^2)) <= r) | ... % top right corner
                    ((x <= r) & (y >= h - r) & (sqrt((x - r).^2 + (y - h + r).^2)) <= r) | ... % bottom left corner
                    ((x >= w - r) & (y >= h - r) & (sqrt((x - w + r).^2 + (y - h + r).^2)) <= r); % bottom right corner
                % Create the rounded rectangle
                rect = ones(size(x));
                rect(mask) = 0;
                msk1 = zeros(size(x));
                msk1(r:end-r,:) = 1;
                msk1(:,r:end-r) = 1;
                antiMsk = ~(~rect | msk1);
                rim = bwmorph(~antiMsk,'remove');
                % Create templates for Red, Green and Gray:
                fnames = {'Red','Green','Gray'};
                color=[];Red = [];Green = [];Gray = [];
                for ii = 1:3
                    eval(['color = Params.Color.' fnames{ii} ';']);
                    r = repmat(color(1),h,w); r(antiMsk) = bcgColor(1); r(rim) = 0;
                    g = repmat(color(2),h,w);g(antiMsk) = bcgColor(2); g(rim) = 0;
                    b = repmat(color(3),h,w); b(antiMsk) = bcgColor(3); b(rim) = 0;
                    rgb = cat(3,r,g,b);%#ok
                    eval([fnames{ii} ' = rgb;'])
                end
                
                for ii = 1:length(obj.pipe)
                    % Change button background color if parameters were set:
                    if isempty(obj.pipe(ii).opts)
                        buttonArray(ii).CData = Gray; % Gray. No parameters.
                    elseif obj.pipe(ii).b_paramsSet
                        buttonArray(ii).CData = Green; % Green. Parameters already set.
                    else
                        buttonArray(ii).CData = Red; % Red. Parameters not set.
                    end
                end
                
            end
            
            function chooseSaveFileName(src,~,obj)
                % Create input dialog to select/change SaveFileName
                btn = gco;
                idxFcn = btn.UserData;
                % Quick undo saving:
                saveArrowHandles = findall(Container.handle,'Tag','saveArrow');
                if strcmpi(src.Text,'undo saving')
                    obj.pipe(idxFcn).b_save2File = false;
                    obj.pipe(idxFcn).saveFileName = '';
                    idx = [saveArrowHandles.UserData] == btn.UserData;
                    if any(idx)
                        delete(saveArrowHandles(idx));
                    end
                    return
                end
                
                info = obj.funcList(strcmp({obj.funcList.name},obj.pipe(idxFcn).name));
                % Create input dialog box:
                if isempty(obj.pipe(idxFcn).saveFileName)
                    defName = info.info.outFileName;
                else
                    defName = obj.pipe(idxFcn).saveFileName;
                end
                [~,~,ext] = fileparts(defName);
                answer = inputdlg('Type file name (leave empty to undo saving):','Save step as',[1 50],{defName});
                if isempty(answer)
                    disp('Operation cancelled by User')
                    return
                end
                
                [~,newName,~] = fileparts(answer{1});
                if isempty(newName)
                    % Undo saving if User erases name.
                    obj.pipe(idxFcn).b_save2File = false;
                    obj.pipe(idxFcn).saveFileName = '';
                    idx = [saveArrowHandles.UserData] == btn.UserData;
                    if any(idx)
                        delete(saveArrowHandles(idx));
                    end
                else
                    % Update saveFileName in pipeline:
                    obj.pipe(idxFcn).b_save2File = true;
                    obj.pipe(idxFcn).saveFileName = [newName, ext];
                    obj.pipe(idxFcn) = obj.setSaveFilename(obj.pipe(idxFcn),false);
                    % Create little arrow to indicate that the data will be
                    % saved.
                    drawSaveArrow(btn);
                end
                % Update tooltips:
                btn.Tooltip = obj.genToolTipTxt(obj.pipe(idxFcn));
                jiggleFig(ancestor(src, 'figure'))
            end
        end
        %%%%%%-------------------------------------------------------------        
    end
    
    methods (Access = {?DataViewer})
        %%%%%-- Methods for interfacing with DataViewer -------------------
        function loadDataFromDataViewer(obj,data,fileDataHistoryInfo)
            % LOADDATAFROMDATAVIEWER methods imports the imaging data from
            % DataViewer to this class.
            
            % Indicate that the input is from DataViewer:
            obj.b_inputFromDataViewer = true;
            obj.b_enforceSaving = false;            
            % Update current data:
            obj.current_data = data;
            % Update folders:
            obj.current_saveFolder = obj.SaveFolderList{1};
            obj.current_rawFolder = obj.RawFolderList{1};
            % Load DataHistory
            obj.loadDataHistory(obj.SaveFolderList{1});
            % Update current info for data stored in RAM
            obj.current_info = fileDataHistoryInfo;
        end                
    end
    
    methods (Access = private)
        
        function loadDataHistory(obj,folder)
            % LOADDATAHISTORY loads the dataHistory structure from the "dataHistory.mat"
            % file in the protocol's saveFolder.
            % This function also cleans-up the dataHistory structure and
            % file if there are missing files in the folder.
            
            dataHistory = struct.empty(0,1);%#ok
            if ~isfile(fullfile(folder,'dataHistory.mat'))
                return
            end
            load(fullfile(folder,'dataHistory.mat'));%#ok
            % Check if all files listed in dataHistory still exist in the
            % saveFolder:
            fileList = getFileList(folder);
            % Clean-up! Remove missing files from dataHistory:
            dataHistory(~ismember({dataHistory.filename}, fileList)) = [];%#ok
            if isempty(dataHistory)%#ok
                delete(fullfile(folder,'dataHistory.mat'));
            else
                % Overwrite dataHistory.mat file:
                save(fullfile(folder,'dataHistory.mat'),'dataHistory');
            end
            obj.dataHistory = dataHistory;%#ok
        end
        
        function saveDataHistory(obj,SaveFolder, filename)
            % SAVEDATAHISTORY creates or overwrites the data history for a
            % .dat or .mat file (filename) inside the dataHistory.mat file.
            
            % Create a new dataHistory.mat file, if it doesn't exists in
            % the SaveFolder
            if isempty(obj.current_info)
                return
            end
            thisDataHistory = struct('filename',filename,'info',obj.current_info);
            if ~isfile(fullfile(SaveFolder,'dataHistory.mat'))
                dataHistory = thisDataHistory;%#ok
                save(fullfile(SaveFolder,'dataHistory.mat'),'dataHistory');
                return
            end
            % Reload dataHistory to ensure that the local one is
            % up-to-date (dataHistory clean-up):
            obj.loadDataHistory(SaveFolder);
            
            % Append info to existing data history file:
            idxFile = strcmp({obj.dataHistory.filename},filename);
            if any(idxFile)
                % Overwrite the existing file with the new data history:
                obj.dataHistory(idxFile) = thisDataHistory;
            else
                % Append DataHistory file with new entry:
                obj.dataHistory(end+1) = thisDataHistory;
            end
            % Overwrite dataHistory.mat file:
            dataHistory = obj.dataHistory;%#ok
            save(fullfile(SaveFolder,'dataHistory.mat'),'dataHistory');
        end
        
        %%%%%%--Helpers for "addTask" and "rmTask" methods ----------------
        function task = setInput(obj,task,inputSource,inputFromSeq,sourceFile)
            % SETINPUT selects the input to the function in "task". It
            % controls for multiple outputs and for functions with no
            % input. It updates the fields of "task" with the input
            % information.
            % !If the User cancels any of the dialogs, the function returns
            % an empty array.
            
            % Check if this is the very first step of the pipeline:
            b_FirstPipeStep = isempty(obj.pipe);
            b_genNewSeq = true; % Flag to create new sequence.
            inputStepIndx = 0; % Pre-set step index.
            if nargin < 5; sourceFile = ''; end
            switch upper(inputSource)
                case '_CURRENT_DATA_'
                    % Default behaviour for functions with data as input.
                    % Get the current sequence:
                    if ~b_FirstPipeStep
                        b_genNewSeq = false;
                        [newInputSource,inputStepIndx] = lookBackOnSeq(obj.pipe(end));
                    else
                        newInputSource = 'folder';
                    end
                    
                    if task.b_hasDataIn && ~obj.b_inputFromDataViewer                        
                        if strcmpi(newInputSource,'folder') || newInputSource.b_hasFileOut
                            inputSource = obj.selectInputFileName(newInputSource,task.name);
                        end
                    else
                        % For functions without data as input, just add a
                        % new step in the sequence.
                        inputStepIndx = length(obj.pipe);
                    end                    
                case '_FOLDER_'
                    % Default behaviour for functions accessing the save
                    % folder.
                    if task.b_hasDataIn
                        inputSource = obj.selectInputFileName(inputSource,task.name);
                    else
                        inputSource = upper(inputSource);
                    end
                    % DO NOTHING. Default behaviour.
                case '_DATAVIEWER_'
                    disp('FIRST STEP FROM DV!');
                    % DO NOTHING. Default behaviour.
                    inputSource = '_CURRENT_DATA_';                                       
                otherwise
                    % For user-defined new sequence.
                    % Here, one can set the input source as:
                    %   1) a function from the existing pipeline.
                    %   2) a file (.dat or .datstat).
                    
                    % Check if the task function needs data:
                    assert(task.b_hasDataIn,...
                        ['The function "' task.name '" does not have "data" as input. Operation aborted!'])
                    % Check if the input source is a file or a function:
                    if endsWith(inputSource,'.dat') || endsWith(inputSource,'.datstat')
                        % The input source is a file from the save folder.
                        fileList = getFileList(obj.SaveFolderList); % Get list of existing data files in the first SaveFolder.
                        idxFile = strcmp(fileList,inputSource);
                        % Check if the input file exists:
                        assert(any(idxFile),'Failed to find file "%s" in SaveFolder!',inputSource);
                    else
                        % The input source is an existing function in the
                        % pipeline. Here, the "inputFromSeq" parameter is used to
                        % locate the function.
                        % Check if the source function exists in the
                        % sequence
                        idxSourceFcn = ( strcmpi(inputSource, {obj.pipe.name}) & arrayfun(@(x) any(x.seq == inputFromSeq),obj.pipe)' );
                        assert(any(idxSourceFcn),'The function "%s" doesn''t exist in sequence "%d"',inputSource,inputFromSeq);
                        % Update source function, in case where the
                        % user-defined one does not have data as output:
                        
                        [stepSource, inputStepIndx] = lookBackOnSeq(obj.pipe(idxSourceFcn));
                        % Raise warning if the source function was changed:
                        if ~isequaln(obj.pipe(idxSourceFcn),stepSource)
                            if isstruct(stepSource)
                                StepSourceName = stepSource.name;
                            else
                                StepSourceName = stepSource;
                            end
                            warning('The input source function "%s" cannot be a source to "%s". The source function was changed to "%s" instead.',...
                                obj.pipe(idxSourceFcn).name,task.name, StepSourceName);
                        end
                        if inputStepIndx
                            idxSourceFcn = ( strcmpi(stepSource.name, {obj.pipe.name}) & arrayfun(@(x) any(x.seq == inputFromSeq),obj.pipe)' );
                            assert(any(idxSourceFcn),'The function "%s" was not found in sequence #%d!',stepSource.name, inputFromSeq);
                            % Check if the source function has Data or File as output:
                            if obj.pipe(idxSourceFcn).b_hasDataOut
                                % For functions with Data as output, force saving data
                                % to temporary file and use the file as input source.
                                obj.pipe(idxSourceFcn).b_save2File = true;
                                obj.pipe(idxSourceFcn) = obj.setSaveFilename(obj.pipe(idxSourceFcn), true);
                                inputSource = obj.pipe(idxSourceFcn).saveFileName;
                            elseif obj.pipe(idxSourceFcn).b_hasFileOut
                                %
                                if ~isempty(sourceFile)
                                    % Do not create a new sequence
                                    b_genNewSeq = any(strcmp(task.name, {obj.pipe([obj.pipe.seq] == obj.pipe(idxSourceFcn).seq).name}));
                                    % Set source file
                                    inputSource = sourceFile;
                                else
                                    % For functions that output one or more files:
                                    nOutFiles = length(obj.funcList(strcmpi(obj.pipe(idxSourceFcn).name,{obj.funcList.name})).info.outFileName);
                                    if nOutFiles > 1
                                        inputSource = obj.selectInputFileName(obj.pipe(idxSourceFcn),task.name);
                                    else
                                        inputSource = obj.funcList(strcmpi(obj.pipe(idxSourceFcn).name,{obj.funcList.name})).info.outFileName;
                                    end
                                end
                            else
                                % DEV
                                error('DEV: This should never be reached.')
                            end
                        else
                            % The source is the folder:
                            if task.b_hasDataIn
                                inputSource = obj.selectInputFileName(inputSource,task.name);
                            else
                                inputSource = upper(inputSource);
                            end
                        end
                    end
            end
            
            if isempty(inputSource)
                % The User cancelled the process during
                % "selectInputFileName" execution.
                task = [];
                return
            end
            % Create a new sequence.
            if b_genNewSeq
                obj.current_seq = obj.current_seq + 1;
                obj.current_seqIndx = 0; % Reset current sequence index.
            end
            % Increment step index:
            obj.current_seqIndx = obj.current_seqIndx + 1;
            % Update task structure
            task.inputSource = inputSource;
            task.inputStepIndx = inputStepIndx;
            task.seq = obj.current_seq;
            task.seqIndx = obj.current_seqIndx;
            %%% LOCAL FUNCTION
            function [newInputSource, newInputStepIndx]= lookBackOnSeq(startStep)
                % Look back on current sequence to get the last
                % function with any outputs. If no outputs are fuond, the
                % FOLDER is used as input.
                % This function deals with functions with inputs!
                % Build a sequence that backtraces the from the startStep
                % up to the folder.
                newInputSource = startStep;
                flag = true;
                while flag
                    if newInputSource.b_hasDataOut || newInputSource.b_hasFileOut
                        break
                    end
                    % Move up in the pipeline
                    if ~newInputSource.inputStepIndx
                        % This means that the previous step is the folder
                        newInputSource = 'Folder';
                        break
                    else
                        % Move up in the pipeline
                        newInputSource = obj.pipe(newInputSource.inputStepIndx);
                        
                    end
                end
                if ~ischar(newInputSource)
                    newInputStepIndx = find(arrayfun(@(x) isequaln(newInputSource,x),obj.pipe));
                else
                    newInputStepIndx = 0;
                end
            end
        end
        
        function filename = selectInputFileName(obj,source,target)
            % SELECTINPUTFILENAME creates a dialog box for the User to
            % select a file that will be the input to the "task". If
            % the "task" field "inputFrom" is a function with multiple
            % files, it will show the possible outputs from the given
            % function. However, if the "inputFrom" is "_LOCAL_", the
            % prompt will show a list of existing files from the first
            % element in the saveFolderList.
            % Input:
            %   source (char): name of the pipeline function OR a folder to get file list from.
            % Output:
            %   filename (char): name of the input file. Empty, if user
            %   cancels.
            
            % For functions as "source":
            if isstruct(source)
                % Get source function info:
                funcInfo = obj.funcList(strcmp(source.name,{obj.funcList.name}));
                % Create dialog box so the user selects the file:
                [indxFile, tf] = listdlg('ListString', funcInfo.info.outFileName,...
                    'SelectionMode','single','PromptString',{'Select a file from:',...
                    ['"' funcInfo.name '" as input to :' ], ['"' target '":']}, 'ListSize',[250,280],'Name', 'Select file');
                if ~tf
                    disp('Operation cancelled by User')
                    filename = '';
                    return
                end
                filename = funcInfo.info.outFileName{indxFile};
            else
                % For "FOLDER" as source, display the .dat/.datstat files from the
                % first item of the SaveFolderList:
                fileList = getFileList(obj.SaveFolderList);
                % If not files exist in the item's save folder, raise a
                % warning and abort:
                if isempty(fileList)
                    w = warndlg(['No valid data files found in folder: ' obj.SaveFolderList{1}], 'Operation aborted!');
                    waitfor(w);
                    filename = '';
                    return
                end
                % Create dialog box
                [indxFile, tf] = listdlg('ListString', fileList,'SelectionMode','single',...
                    'PromptString',{'Select a file as input to:', ['"' target '"']},'ListSize',[250,280],'Name','Select file');
                if ~tf
                    disp('Operation cancelled by User');
                    filename = '';
                    return
                end
                filename = fileList{indxFile};
            end
        end
        
        function step = setSaveFilename(obj,step,b_genTmpFile)
            % SETSAVEFILENAME validates and sets the "saveFileName" during
            % the addTask process. This method applies only to functions
            % that generated Data as output (not files).
            % Inputs:
            %   step (struct): task that is being added to the pipeline.
            %   b_genTmpFile (bool): If TRUE, generates a random file name
            %       with prefix 'tmpFile_'.
            
            if ~step.b_save2File;return;end
            if ~step.b_hasDataOut
                warning('The function "%s" does not have data as output. The Save file command will be ignored.',step.name);
                step.b_save2File = false;
                return
            end
            % Get step's function information:
            funcInfo = obj.funcList(strcmp({obj.funcList.name},step.name)).info;
            % Get file extension:
            [~,~,ext] = fileparts(funcInfo.outFileName);
            % Set save file name:
            if ~isempty(step.saveFileName)
                % Enforce file extension:
                [~,filename,~] = fileparts(step.saveFileName);
                saveFilename = [filename, ext];
            else
                if b_genTmpFile
                    % Create temporary file:
                    [~,~,ext] = fileparts(funcInfo.outFileName);
                    saveFilename = ['tmpFile_' num2str(randi(99999,1,1),'%05i') ext];
                else
                    % Save with default name
                    saveFilename = funcInfo.outFileName;
                end
            end
            
            % Validate if the filename already exists in the pipeline and in the SaveFolder:
            idxFcn = arrayfun(@(x) isequaln(step,x),obj.pipe);
            nameList = [{obj.pipe(~idxFcn).saveFileName}, getFileList(obj.SaveFolderList)'];
            
            if obj.b_overwriteFiles || ~any(strcmp(saveFilename,nameList))
                step.saveFileName = saveFilename;
                return
            end
            % Append indices to file names:
            [stepPrefix,stepNameIndx,fileExt] = splitName(saveFilename);
            [allPrefixes,allIndices] = cellfun(@(x) splitName(x),nameList,'UniformOutput',false);
            
            idx = strcmp(stepPrefix,allPrefixes);
            if any(idx) && ~startsWith(saveFilename,'tmpFile_')
                % Append file name with incremented index:
                % Not applied to temporary files!
                newIndex = max([stepNameIndx, [allIndices{idx}]]) + 1;
                saveFilename = [stepPrefix, '_', num2str(newIndex), fileExt];
                warning('Found duplicate names in the pipeline. The data will be saved as "%s" to avoid overwriting.',saveFilename)
            end
            
            % Update save file name:
            step.saveFileName = saveFilename;
            
            %%% LOCAL FUNCTIONS
            
            function [prefix,index,fext] = splitName(Name)
                % Splits the file names to identify duplicates.
                prefix = [];
                index = [];
                fext = [];
                if isempty(Name);return;end
                [~,Name,fext] = fileparts(Name);
                out1 = regexp(Name,'^(.*?)_(\d+)$','tokens');
                out2 = regexp(Name,'^(.*?)$','tokens');
                if isempty(out1)
                    prefix = out2{1}{1};
                    index = 0;
                else
                    prefix = out1{1}{1};
                    index = str2double(out1{1}{2});
                end
            end            
        end
        
        %%%%%%--Pipeline Log ----------------------------------------------
        function savePipeLog(obj,SaveFolder)
            % SAVEFOLDERLOG saves the obj.folderPipeLog table to the
            % "pipeLog.mat" file in the "SaveFolder".
            % This function checks for the height limit of the table and
            % up to "maxLogRows" and removes older entries before saving.
            
            if height(obj.folderPipeLog) > obj.maxLogRows
                % Remove older entries if log exceeds maximum number of
                % rows (oler entries are on top).
                obj.folderPipeLog(1:height(obj.folderPipeLog) - obj.maxLogRows,:) = [];
            end
            % Save Folder log:
            pipeLog = obj.folderPipeLog;
            save(fullfile(SaveFolder,'pipeLog.mat'),'pipeLog');
        end
        
        function loadPipeLog(obj,SaveFolder)
            % LOADFOLDERLOG sets the log table from the SaveFolder in the
            % obj.folderPipeLog property.
            
            if ~isfile(fullfile(SaveFolder,'pipeLog.mat'))
                obj.folderPipeLog = table();
                return
            end
            load(fullfile(SaveFolder,'pipeLog.mat'));%#ok
            obj.folderPipeLog = pipeLog;
        end
        
        function updatePipeLog(obj,info,b_completed,errMsg)
            % UPDATEFOLDERLOG creates/appends task entries in the
            % folderLog and PipelineSummary tables.
            
            if isa(errMsg,'MException')
                MessageLong = getReport(errMsg,'extended','hyperlinks','off');
                MessageShort = getReport(errMsg,'basic','hyperlinks','off');
            elseif isempty(errMsg)
                MessageLong = 'No Errors';MessageShort = 'No Errors';
            else
                MessageLong = errMsg; MessageShort = errMsg;
            end
            
            thisLog = table(obj.SaveFolderList_truncated(strcmp(obj.current_saveFolder,obj.SaveFolderList)),...
                {info.name},...
                {info.inputSource},...
                {strjoin(info.saveFileName,', ')},...
                b_completed,...
                info.runDatetime,...
                {MessageShort},...
                {MessageLong},...
                'VariableNames', {'SaveFolder','TaskName','InputSource',...
                'SavedFiles', 'Completed', 'RunDateTime',...
                'Messages_short','Messages'});
            % Update Pipeline summary table:
            obj.PipelineSummary = [obj.PipelineSummary; thisLog];
            % Update folder log:
            thisLog = removevars(thisLog,'SaveFolder');
            obj.folderPipeLog = [obj.folderPipeLog; thisLog];
            
        end
        %%%%%%--Pipeline Execution ----------------------------------------
        function forceSaveLastStep(obj)
            % FORCESAVELASTSTEP ensures that the last steps of all sequences
            % are saved. This option is disabled for the DataViewer app.
            
            if ~obj.b_enforceSaving; return; end
            
            % For each existing sequence, force saving the data from the
            % last function that has data as output.
            
            seqIndices = unique([obj.pipe.seq]);
            exp = '^tmpFile_\d{5}\.(dat|datstat)$';
            for ii = 1:length(seqIndices)
                this_seq = obj.pipe([obj.pipe.seq] == seqIndices(ii));
                % Find last step that has data as output:
                idx_last_step = find([this_seq.b_hasDataOut],1,'last');
                if isempty(idx_last_step)
                    continue
                end
                % Get position of the step in the pipeline:
                idxInPipe = arrayfun(@(x) isequaln(x,this_seq(idx_last_step)),obj.pipe);
                % Enforce saving
                obj.pipe(idxInPipe).b_save2File = true;
                
                if  ~isempty(regexp(obj.pipe(idxInPipe).saveFileName, exp, 'once'))
                    % In cases where the last step of a sequence saves a
                    % temporary file, replace it with a default file name and
                    % update the steps that depend on it
                    tmpFileName = obj.pipe(idxInPipe).saveFileName;
                    obj.pipe(idxInPipe).saveFileName ='';
                    % Update Save Filename:
                    obj.pipe(idxInPipe)= obj.setSaveFilename(obj.pipe(idxInPipe),false);
                    % Find all steps that uses the temporary file and
                    % replace it with the new one:
                    indxTmpFileName = find(strcmp({obj.pipe.inputSource},tmpFileName));
                    for jj = 1:length(indxTmpFileName)
                        obj.pipe(indxTmpFileName(jj)).inputSource = obj.pipe(idxInPipe).saveFileName;
                    end
                else
                    % Update Save Filename:
                    obj.pipe(idxInPipe)= obj.setSaveFilename(obj.pipe(idxInPipe),false);
                end
            end
        end
        
        function run_taskOnTarget(obj, task)
            % RUN_TASKONTARGET runs a task in the pipeline structure array in
            % TASK.
            % Input
            %   task(struct): current step from "obj.pipe".
            
            % Create function string and update log table:
            funcStr = createFcnString(obj, task);
            Messages = '';
            %  Execute the task:
            try
                % Control for missing input files:
                if endsWith(task.inputSource,'.dat') || endsWith(task.inputSource,'.datstat')
                    errID = 'MATLAB:Umitoolbox:PipelineManager:FileNotFound';
                    errmsg = ['Input File for function ' task.name ' not found!'];
                    assert(isfile(fullfile(obj.current_saveFolder, task.inputSource)),...
                        errID,errmsg);
                    obj.loadInputFile(task);
                end
                fprintf('\tFunction Name: %s \n\n',task.name);
                % Load options structure in the workspace.
                opts = task.opts; %#ok the "opts" structure is used in the EVAL function.
                % Evaluate function string:
                eval(funcStr);
                % Update log table and tell other methods that the function
                % was successfully run:
                obj.b_state = true;
                % Update data history of current data with task:
                this_info = obj.updateStepInfo(task,true);
            catch ME
                obj.b_state = false;
                Messages = ME;
                disp('FAILED!');
                this_info = obj.updateStepInfo(task,false);
            end
            % Save data to file:
            obj.saveDataToFile(task,~obj.b_state);
            % Update log table of current folder:
            obj.updatePipeLog(this_info,obj.b_state,Messages);
            
        end
        
        function [newSeq,skippedSteps, selFile] = skipSteps(obj,thisSeq)
            % SKIPSTEPS looks in the folder "folderName" for .dat/.mat files
            % that can potentially replace the N first steps of the pipeline
            % sequence "thisSeq".
            % The criteria to replace the pipeline steps are:
            %    1- Same creation date time of the functions.
            %    2- Same function name
            %    3- Same function "opts" parameters
            %    4- No intermediate steps from the file is used as input to
            %    other sequences
            %    Inputs:
            %        thisSeq (struct): current sequence of the pipeline.
            %    Outputs:
            %        newSeq (struct): updated sequence without the redundant
            %            steps.
            %        skippedSteps (cell): list of skipped function names from
            %            "thisSeq".
            %        selFile (char) : selected file to replace sequence
            %           chunk.
            
            if obj.b_inputFromDataViewer && ~isempty(obj.current_info)
                % For DataViewer, also, look at the dataHistory of the
                % current data.
                % Temporarily add the dataHistory of the data in RAM to the
                % "dataHistory" property. This will be removed at the end
                % of this function.
                obj.dataHistory = [obj.dataHistory; struct('filename','self','info',obj.current_info)];
            end
            % Set outputs:
            newSeq = thisSeq;
            skippedSteps = {};
            
            %
            newSeqArr = cell(size(obj.dataHistory));
            erasedStepsArr = newSeqArr;
            nSkippedStepsArr = zeros(size(obj.dataHistory));
            selFile = '';
            
            if ~obj.b_skipSteps
                return
            end
            % Abort,if the dataHistory file doesn't exists.
            if isempty(obj.dataHistory)
                return
            end
            % Prepare the sequence for comparison
            [extendedSeq,b_isValid,extSeqIdx] = prepareSequenceForComparison(thisSeq);
            if ~b_isValid
                % The sequence is not comparable.
                
                % DEV: RAISE WARNING??
                
                return
            end
            
            % Compare each file's dataHistory with the extended sequence:
            
            for ii = 1:length(obj.dataHistory)
                [newSeqArr{ii}, nSkippedStepsArr(ii),erasedStepsArr{ii}] = compareDataHistory(extendedSeq,obj.dataHistory(ii),extSeqIdx,thisSeq);
            end
            % Check for matches:
            if ~any(nSkippedStepsArr)
                % Couldn't find any files to replace steps.
                return
            end
            
            % Select file with the largest number of steps skipped:
            [~,indxSkip] = max(nSkippedStepsArr); indxSkip = indxSkip(1);
            % Set the file to load:
            selFile = obj.dataHistory(indxSkip).filename;
            % Set the new sequence:
            newSeq = newSeqArr{indxSkip};
            % Set skipped steps
            skippedSteps = erasedStepsArr{indxSkip};
            % If the last step of the new sequence has data as output,
            % fix all input source names in subsequent sequences:
            lastDataSaved = erasedStepsArr{indxSkip}(find([erasedStepsArr{indxSkip}.b_hasDataOut] & [erasedStepsArr{indxSkip}.b_save2File],1,'last'));
            if ~isempty(lastDataSaved)
                fixInputSource(lastDataSaved.saveFileName,selFile,thisSeq(1).seq);
            end
            
            % Remove "self" entry from dataHistory:
            idxSelf = strcmp({obj.dataHistory.filename},'self');
            obj.dataHistory(idxSelf) = [];
            %%%%%--Local function ------------------------------------------
            
            function [extSeq, b_isSeq, b_seqIdx]= prepareSequenceForComparison(seq)
                %  PREPARESEQUENCEFORCOMPARISON adds all the information
                %  previous to the sequence and remove extra fields and steps.
                %  It prepares the sequence for comparison with the dataHistory
                %  of existing files.
                
                b_isSeq = true;
                
                % Get the extended sequence all the way up to "FOLDER", excluding steps without output:
                step = seq(end);
                extSeq = step;
                while true
                    if ~step.inputStepIndx
                        break
                    end
                    extSeq = [extSeq; obj.pipe_session(step.inputStepIndx)];%#ok
                    step = obj.pipe_session(step.inputStepIndx);
                end
                extSeq = flipud(extSeq);
                % Identify original sequence in extended one:
                b_seqIdx = arrayfun(@(extElem) any(arrayfun(@(seqElem) isequal(seqElem, extElem), seq)), extSeq);
                % If the extended sequence doesn't contain the whole
                % original sequence, set the boolean flag to FALSE and return:
                if ~all(arrayfun(@(seqElem) any(arrayfun(@(extElem) isequal(seqElem, extElem), extSeq)), seq))
                    extSeq = [];
                    b_isSeq = false;
                    b_seqIdx = false;
                    return
                end
                
                % If the source of the extended sequence is a file, prepend
                % the file's dataHistory.
                dh = [];
                if ~strcmpi(extSeq(1).inputSource,'_FOLDER_')
                    % Find file's data history:
                    dh = obj.dataHistory(strcmp(extSeq(1).inputSource,{obj.dataHistory.filename})).info;
                    dh = rmfield(dh,setdiff(fieldnames(dh),{'name','opts'}));
                    b_seqIdx = [false(size(dh));b_seqIdx];
                end
                % Remove extra fields:
                extSeq = rmfield(extSeq,setdiff(fieldnames(extSeq),{'name','opts'}));
                extSeq = [dh;extSeq];
            end
            
            function [outSeq,nSkippedSteps,erasedSeq] = compareDataHistory(extSeq,dh,seqIdx,originalSeq)
                % Compares the sequence with existing files in the save
                % folder and creates alternative sequences by loading an existing file.
                %
                % Compare only name and opts:
                dh_info = rmfield(dh.info,setdiff(fieldnames(dh.info),{'name','opts'}));
                % Criteria:
                % 1) All common steps should be consecutive from start.
                % 2) At least one step from the real sequence should exist
                %    in the file's datahistory.
                % 3) Only the last of the skipped steps can be an input to
                %    another sequence.
                
                outSeq = [];
                nSkippedSteps = 0;
                erasedSeq = [];
                if length(dh_info) <= length(extSeq)
                    b_isEqualStep = false(size(extSeq));
                    for jj = 1:length(extSeq)
                        b_isEqualStep(jj) = isequaln(dh_info(jj),extSeq(jj));
                        if jj == length(dh_info)
                            break
                        end
                    end
                else
                    b_isEqualStep = false;
                end
                % Check if the criteria apply:
                % 1) All equal steps should be consecutive:
                if ~isscalar(b_isEqualStep)
                    b_isConsecutive = all(diff(b_isEqualStep) < 1);
                else
                    b_isConsecutive = b_isEqualStep;
                end
                % 2) At least, one step is from the real sequence
                b_StepsToSkip = b_isEqualStep & seqIdx;
                % 3) Only the last of the skipped steps can be an input
                % source to another sequence.
                b_hasIntermediateOutputStep = false;
                nextSequences = obj.pipe_session([obj.pipe_session.seq] > originalSeq(1).seq);
                if ~isempty(nextSequences)
                    b_hasIntermediateOutputStep = ~all(ismember({originalSeq(b_StepsToSkip(seqIdx)).saveFileName},{nextSequences.inputSource}));
                end
                % Set new sequence:
                if any(b_StepsToSkip) && b_isConsecutive && ~b_hasIntermediateOutputStep
                    nSkippedSteps = sum(b_StepsToSkip);
                    outSeq = originalSeq(~b_StepsToSkip(seqIdx));
                    if all(b_StepsToSkip(seqIdx))
                        % All steps will be skipped:
                        % In this case, create a dummy sequence:
                        outSeq= originalSeq(1);
                        outSeq.name = ['Skipped sequence # ' num2str(originalSeq.seq)];
                        outSeq.b_save2File = false;
                        outSeq.inputSource = dh.filename;
                        outSeq.inputStepIndx = 0;
                        outSeq.seqIndx = 1;
                        outSeq.saveFileName = {''};
                    else
                        % Set file as input to new sequence:
                        outSeq(1).inputSource = dh.filename;
                        outSeq(1).inputStepIndx = 0;
                    end
                    % Set erased sequence (the inverse of the new sequence):
                    erasedSeq = originalSeq(b_StepsToSkip(seqIdx));
                end
            end
            
            function fixInputSource(oldInputSource,newInputsource,thisSeqIndx)
                % Updates the inputSource (and saveFileName, if
                % appliccable) of all subsequent sequences when skipping a
                % sequence that has a file as input to another one.
                
                stepsToUpdate = strcmp(oldInputSource,{obj.pipe_session.inputSource}) & [obj.pipe_session.seq] > thisSeqIndx;
                if any(stepsToUpdate)
                    % Update inputSource:
                    obj.pipe_session(stepsToUpdate) = arrayfun(@(x) setfield(x,'inputSource',newInputsource),obj.pipe_session(stepsToUpdate));
                end
                %
                if ~obj.b_overwriteFiles
                    return
                end
                % Update saveFileName if file overwritting is enabled:
                stepsToUpdate = strcmp(oldInputSource,{obj.pipe_session.saveFileName}) & [obj.pipe_session.seq] > thisSeqIndx;
                if any(stepsToUpdate)
                    obj.pipe_session(stepsToUpdate) = arrayfun(@(x) setfield(x,'saveFileName',newInputsource),obj.pipe_session(stepsToUpdate));
                end
            end
            
        end
        
        function createFcnList(obj)
            % This function creates a structure containing all information
            % about the analysis functions inside the "Analysis" folder.
            % This information is stored in the "funcList" property of
            % pipelineManager.
            
            % !!For now, it will read only folders directly below the
            % "Analysis" folder. Subfolders inside these folders will not
            % be read!
            
            % Set Defaults:
            default_Output = '';
            default_opts = struct();
            opts_values = struct();
            
            disp('Creating Fcn list...');
            list = dir(fullfile(obj.fcnDir, '*','*.m'));
            for i = 1:length(list)
                out = parseFuncFile(list(i));
                % Validate if all input arguments from the function are
                % "valid" inputs keywords:
                kwrds_args = {'data', 'SaveFolder', 'RawFolder', 'opts'};
                kwrds_out = {'outFile', 'outData'};
                if all(ismember(out.argsIn, kwrds_args)) && all(ismember(out.argsOut, kwrds_out))
                    [~,list(i).name, ~] = fileparts(list(i).name);
                    list(i).info = out;
                    list(i).info.opts_def = list(i).info.opts; % Duplicate default params.
                    % add boolean to indicate if the function as inputs and
                    % outputs (This will be used by other methods)
                    list(i).info.b_hasDataIn = any(contains(list(i).info.argsIn,'data','IgnoreCase',true));
                    list(i).info.b_hasDataOut = any(contains(list(i).info.argsOut,'outData','IgnoreCase',true));
                    list(i).info.b_hasFileOut = any(contains(list(i).info.argsOut,'outFile','IgnoreCase',true));
                    obj.funcList = [obj.funcList ; list(i)];
                end
            end
            disp('Function list created!');
            function info = parseFuncFile(fcnStruct)
                info = struct('argsIn', {},'argsOut', {}, 'outFileName', '', 'opts', [],...
                    'opts_def',[],'opts_vals',[], 'dependency','');
                % Read the '.m' file content and exclude comments (lines
                % starting with the "%" character):
                fid = fopen(fullfile(fcnStruct.folder, fcnStruct.name),'r');
                txt = '';
                while 1
                    tline = fgetl(fid);
                    if tline == -1
                        break
                    end
                    if ~startsWith(strip(tline),'%')
                        txt=[txt,sprintf('%s\n',tline)];%#ok
                    end
                end
                fclose(fid);
                clear fid tline
                % Parse function header to get input and output variables:
                funcStr = erase(regexp(txt, '(?<=function\s*).*?(?=\r*\n)', 'match', 'once'),' ');
                outStr = regexpi(funcStr,'.*(?=\=)', 'match', 'once');
                out_args = regexpi(outStr, '\[*(\w*)\,*(\w*)\]*', 'tokens', 'once');
                info(1).argsOut = out_args(~cellfun(@isempty, out_args));
                [~,funcName,~] = fileparts(fcnStruct.name);
                expInput = ['(?<=' funcName '\s*\().*?(?=\))'];
                str = regexpi(funcStr, expInput, 'match', 'once');
                str = strip(split(str, ','));
                info.argsIn = str(~strcmp(str, 'varargin'));
                % Get Default outputs:
                expOutput = 'default_Output\s*=.*?(?=\n)';
                str = regexpi(txt, expOutput, 'match', 'once');
                if isempty(str)
                    default_Output = '';
                else
                    eval(str)
                end
                info.outFileName = default_Output;
                % Get dependent function:
                dependency = '';
                depStr = regexpi(txt, 'dependency\s*=.*?(?=\n)', 'match', 'once');
                if ~isempty(depStr)
                    eval(depStr)
                end
                info.dependency = dependency;
                % Parse default optional params struct:
                expOpts = 'default_opts\s*=.*?(?=\n)';
                str = regexpi(txt, expOpts, 'match', 'once');
                if ~isempty(str)
                    eval(str)
                    info.opts = default_opts;
                    info.argsIn{end+1} = 'opts';
                    % Parse optional params values struct:
                    optsVals = 'opts_values\s*=.*?(?=\n)';
                    str_opts = regexpi(txt, optsVals, 'match', 'once');
                    if ~isempty(str_opts)
                        eval(str_opts)
                        info.opts_vals = opts_values;
                    end
                end
                % SPECIAL CASE. Look for "object"s as optional arguments in
                % function first lines:
                expObj = 'default_object\s*=';
                str = regexpi(txt, expObj, 'match', 'once');
                if ~isempty(str)
                    info.argsIn{end+1} = 'object';
                end
            end
        end
        
        function fcnStr = createFcnString(obj,task)
            % This method creates a string containing the function to be
            % called during the current task of the pipeline by an EVAL
            % statement. This method is called from "run_taskOnTarget"
            % method.
            % !! If new input or output arguments are created, meaning new
            % argument keywords, this function has to be updated in order the
            % function string to work.
            
            % Input:
            %   task (struct): info of current function to be run on the
            %       current object.
            % Output:
            %   fcnStr (char): string containing call to analysis function
            %   in the current task.
            
            % Create analysis function string:
            fcnStr = '';
            
            argsIn = replace(task.argsIn, ["RawFolder", "SaveFolder", "data"],...
                {['''' obj.current_rawFolder ''''],['''' obj.current_saveFolder ''''],...
                'obj.current_data'});
            argsOut = replace(task.argsOut, ["outData", "outFile"],...
                {'obj.current_data', 'obj.current_outFile'});
            if isempty(argsOut)
                fcnStr = [fcnStr ';' task.name '(' strjoin(argsIn,',') ');'];
            else
                fcnStr = [fcnStr ';' '[' strjoin(argsOut, ',') ']=' task.name '(' strjoin(argsIn,',') ');'];
            end
            fcnStr = strip(fcnStr,'left', ';');
            
        end
        
        function thisStep  = updateStepInfo(obj,step, b_storeInfo)
            % UPDATESTEPINFO creates or  updates the "current_info"
            % structure. The latter contains all information about the functions'
            % parameters used to create the current "data" and when it was run.
            %
            % Input:
            %    step(struct) : current step of the pipeline;
            % Output:
            %   thisStep(struct): current info from current step
            
            funcInfo = obj.funcList(strcmp(step.name, {obj.funcList.name}));
            % Create a local structure with the function's info:
            thisStep = obj.getStepInfo(funcInfo, step.opts, step.inputSource, step.saveFileName);
            if any(strcmp(step.argsOut, 'outFile'))
                % Update saveFileName list with the actual files generated by the function in "step".
                thisStep.saveFileName = obj.current_outFile;
            end
            
            if ~b_storeInfo
                return
            end
            
            % Append to current dataHistory:
            obj.current_info = [obj.current_info;thisStep];
            
            if any(strcmp(step.argsOut, 'outFile'))
                % In case the step ouput is a file, update the
                % dataHistory for each one:
                for jj = 1:length(obj.current_outFile)
                    obj.saveDataHistory(obj.current_saveFolder,obj.current_outFile{jj});
                end
            end
        end
        
        function out = getStepInfo(~,fcnInfo, optsStruct, inputFileName, saveFileName)
            % This function creates a structure containing information about an
            % analysis function.
            
            % Inputs:
            %   fcnInfo (struct): structure containing the function's basic informations with
            %       fields:
            %           -name (char): name of the analysis function.
            %           -folder (char): path where the analysis function file is located.
            %           -creationDatetime(datetime): timestamp of the creation of the
            %               analysis function file.
            %   optsStruct (struct): structure containing optional parameters of the
            %       analysis function.
            %   inputFileName(cell|char): name of the input file(s) to the function.
            %   saveFileName(cell|char): name of the output file(s) from the function.
            %   This field is used just by functions that create files already. Just to
            %   keep track of the files that were created.
            % Output:
            %   out (struct): structure with the information necessary for the
            %       dataHistory variable in the data's metaData.
            
            if ischar(saveFileName)
                saveFileName = {{saveFileName}};
            end
            out = struct('runDatetime', datetime('now'), 'name', {fcnInfo.name},...
                'folder', {fcnInfo.folder}, 'creationDatetime',...
                datetime(fcnInfo.datenum, 'ConvertFrom', 'datenum'),...
                'opts', optsStruct, 'inputSource',inputFileName, 'saveFileName',saveFileName);
        end
        
        function loadInputFile(obj,step)
            % This function loads the data and metaData (if applicable)
            % from a .DAT or .MAT file indicated by the inputFileName field
            % in the "step" structure.
            % Input:
            %   step (struct): structure containing the info of the current
            %   task that will be executed inside method
            %   "run_taskOnTarget".
            
            fprintf('Input file name: "%s"\n', step.inputSource);
            % Load the input file:
            obj.current_data = loadData(fullfile(obj.current_saveFolder, step.inputSource));
            %
            obj.current_info = [];
            % Update Data History file handle:
            obj.loadDataHistory(obj.current_saveFolder);
            if ~isempty(obj.dataHistory)
                % Update current info:
                idxFile = strcmp({obj.dataHistory.filename},step.inputSource);
                if any(idxFile)
                    obj.current_info = obj.dataHistory(idxFile).info;
                end
            end
        end
        
        function saveDataToFile(obj,step,b_failed)
            % SAVEDATATOFILE looks back in the pipeline from "step" for tasks
            % with "data" or "stats data" as output and saves the current data to a
            % file. This method will look back on
            % Input:
            %    step(struct) : info of the current task in the pipeline.
            %    b_failed (bool): If TRUE, this means that the "step"
            %       execution failed. In this case, we look for the previous
            %       step that generated the "current_data" and save it. If
            %       FALSE, we just save the data to a file with name
            %       "step.saveFileName".
            
            if (b_failed && ~obj.b_saveDataBeforeFail) || (~b_failed && ~step.b_save2File)
                return
            end
            
            %
            if b_failed
                % Look back in pipeline for steps with "data" or "stats data"
                % as output and save the current data using the task's info:
                
                % Get the sequence up until the last step:
                this_seq = obj.pipe_session([obj.pipe_session.seq] == step.seq);
                stepIndx = findStep(step,this_seq);
                this_seq = this_seq(1:stepIndx-1);
                %
                for ii = length(this_seq):-1:0
                    if ~ii || this_seq(ii).b_hasDataOut
                        % Skip step without data output
                        break
                    end
                end
                if ~ii
                    warning('Unable to save data before failed task. No data to be saved was found!')
                    return
                end
                % Force saving:
                this_seq(ii).b_save2File = true;
                if startsWith(this_seq(ii).saveFileName, 'tmpFile_')
                    % Rename the existing temporary file:
                    oldName = this_seq(ii).saveFileName;
                    this_seq(ii).saveFileName = '';
                    newName = obj.setSaveFilename(this_seq(ii),false);
                    % Rename:
                    movefile(fullfile(obj.current_saveFolder,oldName),...
                        fullfile(obj.current_saveFolder,newName));
                    % Save data history:
                    obj.saveDataHistory(obj.current_saveFolder,newName);
                    return
                end
                % Get last "savable" step in sequence:
                stepToSave = obj.setSaveFilename(this_seq(ii),false);
                fprintf('The data from the intermediate step "%s" will be saved instead.\n',stepToSave.name);
            else
                % Use step info:
                stepToSave = step;
            end
            
            
            % Save current data to file:
            saveData(fullfile(obj.current_saveFolder,stepToSave.saveFileName),...
                obj.current_data);
            % Save data history:
            obj.saveDataHistory(obj.current_saveFolder,stepToSave.saveFileName);
        end
        
        function deleteTemporaryFiles(~,folder)
            % DELETETEMPORARYFILES removes .dat and .mat files from
            % "folder" that were automatically generated during the
            % pipeline due to the existence of branches. The files to be
            % deleted are appended with the "timeTag" of the current
            % pipeline.
            
            % Get list of files in folder:
            list = getFileList(folder);
            % delete files with the "timeTag":
            idxTemp = startsWith(list,'tmpFile_');
            if any(idxTemp)
                fprintf('Deleting pipeline temporary files in folder "%s"...\n',folder);
                cellfun(@(x) delete(fullfile(folder,x)),list(idxTemp));
                disp('Done.')
            end
        end
        
        function genErrorReport(obj)
            % GENERRORREPORT saves the error messages from the Pipeline
            % Summary table to a .txt file inside the folder
            % "PipelineErrorLogs" folder in protocol's save folder.
            
            % Check if any error occurred in the pipeline
            if all(obj.PipelineSummary.Completed)
                return
            end
            
            % Ask User if he/she wants to save the error log:
            answer = questdlg('One or more steps of the pipeline failed. Generate error log file?',...
                'Errors found!', 'Yes','No','Yes');
            waitfor(answer);
            if strcmpi(answer, 'no')
                return
            end
            % Repackage error messages into string:
            str = sprintf(['-------------------- Pipeline error log --------------------\n'...
                'Pipeline executed at:%s\nReport generated at: %s\nTotal number of failed tasks: %d\n%s\n'],...
                datestr(datetime(obj.timeTag,'InputFormat','_ddMMyyyyHHmmss')),...
                datestr(datetime('now')),sum(obj.PipelineSummary.Completed), repmat('-',1,60));
            % Get error messages in execution order:
            errorTab = obj.PipelineSummary(~obj.PipelineSummary.Completed,:);
            headers = errorTab.Properties.VariableNames;
            sel_headers = {'SaveFolder','TaskName','InputSource','RunDateTime','Messages'};
            [~,indx_headers] = ismember(headers,sel_headers);
            for ii = 1:height(errorTab)
                %%%% TBD %%%%%
                
                
                
                
                
                
                
                
                %%%%%% OLD SECTION %%%%%%%%%%%%
                info = table2cell(errorTab(ii,:));
                id = [headers(indx_headers([2 1 3 4])); info(indx_headers([2 1 3])) {datestr(info{indx_h})}];                
                % Trim error messsage to remove references to
                % PipelineManager methods:
                idx = strfind(info{indx_headers(4)},'Error in PipelineManager');
                msg = info{indx_headers(4)}(1:idx(1)-1);
                str = [str, sprintf('Recording Info:\n\t%s : %s\n\t%s : %s\n\t%s : %s\n\t%s : %s\n\t%s : %s\n\t%s : %s\n',id{:})];%#ok
                str = [str, sprintf('Error Message:\n""\n%s\n""\n%s\n', msg,repmat('-',1,60))];%#ok
            end
            % Save to .txt file:
            if obj.b_inputFromDataViewer
                % For DataViewer:
                folder = obj.projectFolder;
            else
                folder = fullfile(obj.projectFolder,'PipelineErrorLogs');
            end
            if ~exist(folder,'dir')
                mkdir(folder);
            end
            filename = ['error_log_' datestr(datetime(obj.timeTag,'InputFormat','_ddMMyyyyHHmmss'),'dd_mm_yyyy_HH_MM'), '.txt'];
            fid = fopen(fullfile(folder,filename), 'w');
            fprintf(fid,'%s',str);
            fclose(fid);
            % Open system's file explorer:
            openFolder(folder);
        end
        %%%%%%-- WAITBAR methods-------------------------------------------
        function setWaitBar(obj,tag,varargin)
            % This method creates two "waitbar" dialogs.
            % The first shows the progress of the pipeline runs across objects
            % while the second one shows the progress of tasks in a given
            % object.
            % Inputs:
            %   tag (char): "Initialize" : creates the 2 waitbars.
            %               "UpdateItem" : updates bar1.
            %               "UpdateTask" : updates bar2.
            
            p = inputParser;
            addRequired(p,'obj')
            addRequired(p,'tag',@ischar)
            addOptional(p, 'currBarVal',0, @(x) isnumeric(x) & x >= 0)
            addOptional(p, 'totalBarVal',1, @(x) isnumeric(x) & x >= 0)
            addParameter(p,'taskName','',@ischar);
            parse(p,obj,tag,varargin{:})
            barVal = p.Results.currBarVal;
            totalBarVal = p.Results.totalBarVal;
            taskName = p.Results.taskName;
            clear p
            
            % Control for invalid waitbar handles:
            if ~strcmp(tag, 'Initialize')
                b_HandleExist = (ishandle(obj.h_wbItem) & ishandle(obj.h_wbTask));
                if ~b_HandleExist
                    return
                end
            end
            
            
            switch tag
                case 'Initialize'
                    obj.h_wbItem = waitbar(0,'Initializing Pipeline...',...
                        'Name','Pipeline Progress',...
                        'CreateCancelBtn', @obj.wb_cancelBtn);
                    setappdata(obj.h_wbItem, 'b_abortPipe', 0);
                    obj.h_wbItem.Children(2).Title.Interpreter = 'none';
                    
                    obj.h_wbTask = waitbar(0,'Initializing Task...','Name','',...
                        'CloseRequestFcn',@DoNothing);
                    obj.h_wbTask.Children(1).Title.Interpreter = 'none';
                    
                case 'UpdateItem'
                    waitbar(barVal/totalBarVal, obj.h_wbItem, ['Item ' num2str(barVal)...
                        '/' num2str(totalBarVal)]);
                    obj.h_wbTask.Name = obj.current_saveFolder;
                case 'UpdateTask'
                    waitbar(barVal, obj.h_wbTask, ['Running "' taskName '"']);
            end
            
            function DoNothing(~,~)
                % Empty callback to avoid closing Waitbar #2
            end
        end
        
        function wb_cancelBtn(obj,src,evnt)
            % Callback of cancel button in waitbar1 ("h_wbItem").
            % This callback triggers the cancellation of the current
            % pipeline when the user clicks on the cancel button.
            
            fprintf('>>>>>>>>>>>>>>>>>>Cancelling Pipeline...>>>>>>>>>>>\n');
            
            src.String = 'Wait!';
            if strcmp(evnt.EventName, 'Action')
                set(src.Parent.Children(2).Title, 'String', 'Please Wait. Stopping Pipeline...');
                setappdata(obj.h_wbItem, 'b_abortPipe', 1);
            end
        end
        %%%%%%-------------------------------------------------------------
        function txt = textifyOpts(~,opts)
            % TEXTIFYOPTS creates a formatted text version of the "opts"
            % structure.
            
            logicMap = containers.Map([true,false],{'Yes','No'});
            fn = fieldnames(opts);
            vals = cell(size(fn));
            for ii = 1:length(fn)
                val = opts.(fn{ii});
                if isnumeric(val)
                    vals{ii} = num2str(val);
                elseif ischar(val)
                    vals{ii} = val;
                elseif iscell(val)
                    vals{ii} = strjoin(val,', ');
                elseif islogical(val)
                    vals{ii} = logicMap(val);
                else
                    error('Unknown value data type')
                end
            end
            if size(fn,1)> size(fn,2)
                fn = fn'; vals = vals';
            end
            info = vertcat(fn,vals);
            txt = [sprintf('Parameters:'), sprintf('\n\t%s: "%s"',info{:})];
        end
        
        function tipTxt = genToolTipTxt(obj,step)
            % Add tooltips for each one:
            if ~isempty(step.opts)
                tipTxt = obj.textifyOpts(step.opts);
                if ~isempty(step.saveFileName)  && ~startsWith(step.saveFileName,'tmpFile_')
                    tipTxt = [tipTxt, sprintf('\n%s',repmat('-',1,20)),  sprintf('\nSave to file: "%s"',step.saveFileName)];
                end
            else
                tipTxt = 'No Parameters';
            end
            
            if step.inputStepIndx
                source = obj.pipe(step.inputStepIndx).name;
            else
                if obj.b_inputFromDataViewer
                    source = 'DataViewer';
                else
                    source = 'Folder';
                end
            end
            % Add input source to data tip:
            tipTxt = [tipTxt, sprintf('\n%s',repmat('-',1,20)),sprintf('\nInput From: "%s"',source)];
            sourceFile = step.inputSource;
            if strcmpi(step.inputSource, '_CURRENT_DATA_') || startsWith(sourceFile, 'tmpFile_')
                return;
            end
            if step.b_hasDataIn
                % Add source file name
                tipTxt = [tipTxt, sprintf('\nInput File: "%s"',sourceFile)];
            end
        end
        
        function indx = findStep(~,step,thisPipe)
            % This function gives the index of the task "step" in the pipeline "pipe"
            % It compares all fields from the structure to identify the
            % step.
            
            step_reduced = rmfield(step,{'b_save2File','saveFileName'});
            pipe_reduced = arrayfun(@(x) rmfield(thisPipe,{'b_save2File','saveFileName'}));
            
            indx = find(arrayfun(@(x) isequal(x,step_reduced),pipe_reduced));
        end
        
        function list_truncated = truncateFolderList(~,list)
            % TRUNCATEFOLDERLIST reduces the size of the path by replacing
            % the common segments with "...".
            
            % Split the paths
            list_split = cellfun(@(x) strsplit(x, filesep), list, 'UniformOutput', false);
            
            % Find the maximum number of segments in any path
            maxSegments = max(cellfun(@length, list_split));
            
            % Convert the cell array to a matrix of strings
            stringMat = strings(length(list_split), maxSegments);
            for ii = 1:length(list_split)
                stringMat(ii, 1:length(list_split{ii})) = string(list_split{ii});
            end
            if length(list) > 1
            % Identify common segments and missing segments
            b_isCommon = all(stringMat == stringMat(1, :), 1);
            b_isMissing = any(stringMat == "", 1);
            
            % Adjust common segments indicator based on missing segments
            b_isCommon(find(b_isMissing, 1, 'last')-1 : end) = false;
            
            % Create new truncated list
            string_truncated = [repmat("...", size(stringMat, 1), 1), stringMat(:, ~b_isCommon)];
            else
                string_truncated = ["..." stringMat(end)];
            end
            % Rebuild paths
            list_truncated = cell(size(list));
            for ii = 1:size(string_truncated, 1)
                str = string_truncated(ii,:);
                list_truncated{ii} = char(strjoin(str(str~=""), filesep));
            end
          
        end
        %%%%%%--- Helper of "setOpts" -------------------------------------
        function [out,state] = buildInputDlg(~,fcnName,fields,currVals,defVals,listVals,typeVals)
            % This function creates an input dialog for user data entry.
            
            state = true; % Boolean flag to indicate if user cancelled or not the process.
            % Create output variable with current values:
            out = {};
            currOpts = {};
            for i = 1:length(fields)
                currOpts(i,1) = fields(i);
                currOpts(i,2) = currVals(i);
            end
            
            screenSize = get(0, 'ScreenSize');
            xyPos(1)= (screenSize(3) / 2) - 310;
            xyPos(2)= (screenSize(4) / 2) - 240;
            
            dlg = uifigure('Name',['Set Parameters for: ' fcnName],...
                'NumberTitle','off',...
                'Position',[xyPos(1),xyPos(2),310,240],...
                'MenuBar','none',...
                'ToolBar', 'none',...
                'Visible','off',...
                'Resize', 'on',...
                'CloseRequestFcn', @figCloseRequest);
            myFontSize = 12;
            
            % Create grid layout:
            g = uigridlayout(dlg);
            g.ColumnWidth = {max(cellfun(@(x) length(x), fields))*myFontSize,'1x'};
            g.ColumnWidth = {'1x','1x'};
            g.ColumnSpacing = 5;
            % Set RowHeight of gridLayout depending on the type of variable:
            idx = strcmpi('charArrayMultiSelect', typeVals);
            rh = repmat({'1x'},1,length(idx));
            for i = 1:length(idx)
                if ~idx(i)
                    rh{i} = 30;
                end
            end
            g.RowHeight = [rh, {60}];
            % Update figure height:
            dlg.Position(4) = sum([g.RowHeight{:}, 2*g.RowSpacing, g.Padding(2)]);

            for i = 1:length(fields)
                lb = uilabel(g,'Text', [fields{i} ': ']);
                lb.FontSize = myFontSize;
                lb.HorizontalAlignment = 'center';
                lb.Layout.Row = i;
                lb.Layout.Column = 1;
                % Create Value entry objects:
                switch typeVals{i}
                    case{'numericArray','logical', 'charArray'}
                        vo = uidropdown(g);
                    case 'charArrayMultiSelect'
                        vo = uipanel(g, 'Scrollable', 'on');
                    case {'numericRange'}
                        vo = uieditfield(g, 'numeric', 'ValueChangedFcn', @lockTextField);
                    otherwise
                        vo = uieditfield(g, 'ValueChangedFcn', @lockTextField);
                end
                % Set position of element in uigrid:
                vo.Layout.Row = i;
                vo.Layout.Column = 2;
                
                % Populate elements with current values:
                switch typeVals{i}
                    case 'numericArray'
                        vo.Items = arrayfun(@(x) num2str(x), listVals{i}, 'UniformOutput',false);
                        vo.Value = vo.Items(listVals{i} == currVals{i});
                    case 'charArray'
                        vo.Items = listVals{i};
                        vo.Value = vo.Items(strcmp(listVals{i},currVals{i}));
                    case 'charArrayMultiSelect'
                        % Create uipanel with series of checkboxes:
                        idxDef = ismember(listVals{i},currVals{i});
                        glChar = uigridlayout(vo,[length(listVals{i}),1]);
                        glChar.RowHeight = repmat({20},size(listVals{i}));
                        glChar.Scrollable = 'on';
                        for jj = 1:length(listVals{i})
                            c = uicheckbox('Parent',glChar, 'Text', listVals{i}{jj},...
                                'Value', idxDef(jj), 'ValueChangedFcn', @lockCheckBox);
                            c.Layout.Row = jj;
                        end
                        % Resize figure to accomodate checkbox list:
                        dlg.Position(4) = dlg.Position(4) + 20*length(listVals{i});                        
                    case 'logical'
                        keys = {'Yes','No'};
                        [~,locB] = ismember([true, false], listVals{i});
                        vo.Items = keys(locB);
                        vo.Value = vo.Items(listVals{i} == currVals{i});
                    case 'numericRange'
                        vo.Value = currVals{i};
                        % Set min and max range:
                        vo.Limits = [listVals{i}];
                    otherwise
                        vo.Value = num2str(currVals{i});
                        idx_char = cellfun(@ischar, listVals{i});
                        name = strjoin(cellfun(@(x) ['"', x, '"'],listVals{i}(idx_char), 'UniformOutput', false),', ');
                        if ~all(idx_char)
                            % Check if numeric values are scalar or an array.
                            if numel(listVals{i}{~idx_char}) > 1
                                vo.Tooltip = ['Type ' name ' or a range of numbers separated by a semicolon (ex. 0;2;3;4).'];
                            else
                                vo.Tooltip = ['Type ' name ' or a single number.'];
                            end
                        else
                            vo.Tooltip = 'Type a string';
                        end
                end
            end
            % Add "Save button"
            g2 = uigridlayout(g);
            g2.Padding = [15 0 15 0];
            btnSave = uibutton(g2, 'Text', 'Ok', 'BackgroundColor', [0 .7 0], 'ButtonPushedFcn',@saveParams);
            btnSave.Layout.Row = 1;
            btnSave.Layout.Column = 1;
            btnReset = uibutton(g2, 'Text', 'Reset', 'BackgroundColor', [.7 .7 .7],...
                'ButtonPushedFcn',@change2Defs);
            btnReset.Layout.Row = 1;
            btnReset.Layout.Column = 2;
            btnReset.Tooltip = 'Reset current values to function''s default';
            movegui(dlg,'center');
            dlg.Visible = 'on';
            pause(.01);
            waitfor(dlg)
            
            % Callbacks for pushbutton and uifigure:
            function change2Defs(src,~)
                % This function changes all fields back to the default values.
                disp('Changing to default...');
                gl = src.Parent.Parent;
                nRows = length(gl.RowHeight)-1;
                layout_info = arrayfun(@(x) get(x, 'Layout'),gl.Children);
                for ii = 1:nRows
                    valueObj = gl.Children([layout_info.Row] == ii & [layout_info.Column] == 2);
                    if isa(valueObj, 'matlab.ui.control.DropDown')
                        switch typeVals{ii}
                            case {'numericArray', 'logical'}
                                idx_def = listVals{ii} == defVals{ii};
                            case 'charArray'
                                idx_def = strcmp(listVals{ii}, defVals{ii});
                        end
                        valueObj.Value = valueObj.Items(idx_def);
                    elseif isa(valueObj,'matlab.ui.container.Panel')
                        % For charArrayMultiSelect case:
                        idxDefReset = strcmpi(defVals{ii}, listVals{ii});
                        arrayfun(@(x,y) set(x,'Value', y), valueObj.Children.Children, idxDefReset);
                    else
                        valueObj.Value = defVals{ii};
                    end
                end
            end
            function saveParams(src,~)
                % This callback saves the parameters selected by the user in the
                % GUI to the "out" variable and closes the figure;
                gl = src.Parent.Parent;
                nRows = length(gl.RowHeight)-1;
                layout_info = arrayfun(@(x) get(x, 'Layout'),gl.Children);
                for ii = 1:nRows
                    valueObj = gl.Children([layout_info.Row] == ii & [layout_info.Column] == 2);
                    if isa(valueObj,'matlab.ui.container.Panel')
                        % Special case: get checkbox values inside uipanel:
                        out{ii,2} = listVals{ii}(arrayfun(@(x) x.Value, valueObj.Children.Children));
                    else
                        out{ii,2} = valueObj.Value;
                    end
                end
                % Clean "out" before completion:
                for ii = 1:size(out,1)
                    out{ii,1} = currOpts{ii,1};
                    switch typeVals{ii}
                        case 'numericArray'
                            out{ii,2} = str2double(out{ii,2});
                        case {'charArray', 'charArrayMultiSelect'}
                            %Do Nothing%
                        case 'numericRange'
                            %Do Nothing%
                        case 'logical'
                            if strcmp(out{ii,2},'Yes')
                                out{ii,2} = true;
                            else
                                out{ii,2} = false;
                            end
                        case 'mixArray'
                            % Transform string digits into double:
                            tmp = str2num(erase(out{ii,2},' '));
                            if ~isempty(tmp)
                                out{ii,2} = tmp;
                            end
                        otherwise
                            % This should not be reached.
                            error('Unknown data type')
                    end
                end
                delete(src.Parent.Parent.Parent); % Close figure.
            end
            function figCloseRequest(src,~)
                % Displays a message to user and erase output:
                out = {};
                state = false;
                warning('off','backtrace')
                warning('Operation cancelled by User! Changes won''t be applied!');
                warning('on','backtrace')
                delete(src);
            end
            function lockCheckBox(src,~)
                % This callback avoids the unchecking of the last checked box.
                idxState = arrayfun(@(x) x.Value, src.Parent.Children);
                if ~any(idxState)
                    src.Value = 1;
                end
            end
            function lockTextField(src,evnt)
                % This callback avoids leaving any input field EMPTY.
                if ( isempty(evnt.Value) ) || ( ~isnumeric(evnt.Value)  && isempty(strip(evnt.Value)) )
                    beep
                    src.Value = evnt.PreviousValue;
                end
            end
        end               
        
    end
    
end
