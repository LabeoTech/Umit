classdef EventsManager < handle
    % EVENTSMANAGER. A class to manage triggers and meta data (event IDs and names)
    %   in order to create an "events.mat" file to be used by umIT. This
    %   class deals exclusively with data generated by LabeoTech imaging
    %   systems (e.g. OiS200).
    properties
        trigThr = 'auto'; % Trigger detection Threshold in volts (Default = 'auto'). The 'auto' means that the threshold will be at 70% of the signal amplitude.
        trigType char {mustBeMember(trigType,{'EdgeSet','EdgeToggle'})} = 'EdgeSet' % Trigger type.
        trigChanName = {''}; % Name of AI channel(s) containing the triggers.
        minInterStim single {mustBeNonnegative} = 2 % Minimal inter stim time (in seconds). This param. is used to identify Bursts in analogIN. !This value should be higher than the inter-burst value to work!
    end
    properties (SetAccess = private)
        dictAIChan cell = {'CameraTrig', 'CameraTrig2', 'InputTrigger',...
                           'StimAna1','StimAna2', 'StimDig', 'Optogen', 'Unused',...
                           'AI1', 'AI2','AI3','AI4','AI5','AI6','AI7','AI8'}; %  List of all available channels from Imaging system:
        AIChanList cell % List of Analog IN channels obtained from "AcqInfo".
        DataFolder char % Folder containing the ai_xxxx.bin and (optionally) the Event list file.        
        AcqInfo struct % Content of the info.txt file as a structure.
        AnalogIN single % Array of analog input data.
        sr single {mustBePositive} = 10000; % Sample rate of analog input channels in Hz.
        timestamps single {mustBeNonnegative} % Time stamps in seconds of triggers.
        state uint8 {mustBeNonnegative} % State of triggers (1= ON, 0 = OFF)
        eventID uint16 {mustBePositive} % Index of each condition (1, 2, 3 ...)
        eventNameList cell % Name of each condition.
        b_isDigital logical = false; % TRUE for digital stimulation using OiS200 as master.
        minTrigAmp single {mustBePositive} = .15; % Minimal signal amplitude (in Volts). Used when the trigger threshold is "auto". Ignored otherwise.        
    end
    properties (Access = private)
        warnOrigState % original state of Matlab's warnings. This will be restored at this class destruction.
        EventFileName char % Name of the event file containing events information (.csv, .txt, .vpixx ...).
        ParseMethods = {'none','csv','vpixx'}; % List of valid parse methods.
        privateEventFileParseMethod;
    end
    properties (Dependent)
        EventFileParseMethod char % Name of the method to read the Event File. {'CSV','vpixx'};
    end
        
    methods
        function obj = EventsManager(DataFolder,varargin)
            % This is the constructor method.
            % It instantiates the object and sets the values for the
            % DataFolder and EventFileName properties.
            % It reads the analog IN channels and the info.txt as well.
            % Inputs:
            %   DataFolder (char): path to the folder containing the
            %       ai_xxxx.bin data and "info.txt" file.
            %   ParseMethod (optional, char): Name of the parsing method to
            %   apply to the event file containing the list of event
            %   IDs:{'none'(default),'csv','vpixx'}.
            
            % Input validation:
            p = inputParser;
            addRequired(p,'DataFolder',@isfolder)            
            addOptional(p, 'ParseMethod','none',@(x) ismember(lower(x),obj.ParseMethods));            
            parse(p,DataFolder,varargin{:});
            
            % Disable backtrace warnings:
            obj.warnOrigState = warning;
            warning('off', 'backtrace');
            
            % Set main properties:
            obj.DataFolder = p.Results.DataFolder;            
            obj.EventFileParseMethod = lower(p.Results.ParseMethod);            
            % Set properties based on the info.txt file:
            obj.setInfo;
            % Set AnalogIN property:
            obj.setAnalogIN;   
            % Detect internally-generated triggers:            
            if ~isempty([obj.trigChanName{:}])
                obj.getTriggers;            
            end
            % Force EventFileParseMethod to "none" if the stimulus is
            % digital. In this case, the event info should already be
            % stated in the "info.txt" file (to be confirmed)
            if obj.b_isDigital && ~strcmpi(obj.EventFileParseMethod, 'none')
                warning('Event file parsing method set to "none" because the stimulus is digital.')
                obj.EventFileParseMethod = 'none';
            end
        end
        function set.EventFileParseMethod(obj,parseMethod)
            % Set method for event file parse method. Just checks if the
            % input is valid. Valid parsing methods are stored in the
            % property "ParseMethods".
            
            parseMethod = convertStringsToChars(parseMethod);
            validateattributes(parseMethod,{'char'},{'scalartext'}, 'set.EventFileParseMethod');
            msg = [sprintf('Invalid parse method "%s". It must be one of the following:',parseMethod),...
                sprintf('\n%s',obj.ParseMethods{:})];
            assert(ismember(parseMethod,obj.ParseMethods),msg);
            obj.privateEventFileParseMethod = parseMethod;                        
        end
        
        function out = get.EventFileParseMethod(obj)
           out = obj.privateEventFileParseMethod; 
        end
               
        function set.trigChanName(obj, trigName)
            % Set method for trigger channel name. 
            % Forces the property to a cell.
            if ischar(trigName)                
                obj.trigChanName = {trigName};
            elseif iscell(trigName)
                obj.trigChanName = trigName;
            else
                error(['Format ' class(trigName) ' not supported! It must be char or cell array of chars.'])
            end
        end

        function readEventFile(obj, varargin)
           % READEVENTFILE reads the content of an event file containing a
           % list of event Names. The file will be parsed using one of the
           % parsing methods available in this class (e.g., for .CSV,
           % .vpixx) and set by the "EventFileParseMethod" property. This
           % property is set at the class construction.
           % If the "EventFileName" is not provided, this function will
           % look for the file with the valid extension (.csv,
           % .vpixx) inside the "DataFolder" and parse it. Override this by
           % giving the full path of the "EventsFileName" as input.
           % For .CSV files, the list of events should be arranged in a
           % column with a HEADER (a header is necessary!) in the first row.
           % Multiple columns will be merged as a single event per row. 
           % It is possible to select  a subset of columns by providing the 
           % names of the columns "CSVcolNames" as input (Case sensitive!).
           % 
           % Inputs (Optional):
           %   EventFileName (char): full path to a valid file containing
           %    the event IDs/Names to be parsed using the parse method set
           %    in the "EventFileParseMethod" property.
           %   CSVcolNames (cell): name of column(s) from a .CSV file to be
           %    read. If more than one column is provided, each row will
           %    be merged into a single one (this parameter is ignored for
           %    other parsing methods).           
           %
           % Examples:
           %  1 - Automatic search for a .CSV file with a single column:
           %    readEventFile();
           %  2 - Read an specific .CSV file:
           %    readEventFile('C:/FULLPATH/FILENAME.CSV');
           %  3 - Read a subset of columns from a .CSV file:
           %    readEventFile('CSVcolNames',{'Col1'',Col2','Col5'};
           %  4 - Read a subset o columns from an specific .CSV file:
           %    readEventFile('C:/FULLPATH/FILENAME.CSV','CSVcolNames',{'ThisOne'});
           
           p = inputParser;
           addRequired(p,'obj')
           addOptional(p,'EventFileName','',@(x) ischar(x) | isempty(x));
           addParameter(p,'CSVcols',{''},@(x) iscell(x) & ischar([x{:}]));
           parse(p,obj,varargin{:});
           %
           evFile = p.Results.EventFileName;
           colNames = p.Results.CSVcols;
           %
           if strcmpi(obj.EventFileParseMethod,'none')
               return
           end
           if ~isempty(evFile)
               % For a specific event file:
               if isempty(fileparts(evFile))
                   evFile = fullfile(obj.DataFolder,evFile);                   
               end
               % Check if the file exists. If not, raise a warning and
               % return:
               if ~exist(evFile,'file')                   
                   warning('Operation aborted. Events file "%s" does not exist!',evFile);
                   return
               end
               evFile = {evFile};
           else
               % For automatic detection of event files:
               fList = [dir(fullfile(obj.DataFolder,'*.csv'));...
                   dir(fullfile(obj.DataFolder,'*.vpixx'));...
                   dir(fullfile(obj.DataFolder,'*.txt'))];
               evFile = fullfile({fList.folder},{fList.name});
               if isempty([evFile{:}])
                   warning('Event list not found! Event IDs and names will not be updated!')
                   return
               end
           end           
           % Try to parse files until it works:
           evID = []; evNames = {};
           for ii = 1:length(evFile)
               obj.EventFileName = evFile{ii};
               try % try-catch is here just to supress errors from private functiosn when non-event files are read. Errors or warnings will be raised here instead.
                   if strcmpi(obj.EventFileParseMethod,'csv') && endsWith(obj.EventFileName, '.csv')
                       [evID, evNames] = obj.readCSVfile(colNames);
                   elseif strcmpi(obj.EventFileParseMethod,'vpixx') && (endsWith(obj.EventFileName, '.vpixx') || endsWith(obj.EventFileName, '.txt'))
                       [evID, evNames] = obj.readVpixxFile;
                       
                       % Add more elseif statements when new parsing methods
                       % are added.
                       %                elseif
                       %
                   else
                       continue
                   end
               catch                    
                   %%% Do nothing
               end
               if ~isempty(evID)
                   disp(['Event list updated from file "' obj.EventFileName '"'])
                   break
               end
           end
           % Throw warning if no event file was specified and no file was
           % successfully read:
           if isempty(p.Results.EventFileName) && isempty(evID)
               warning('Event File parsing aborted! Failed to parse "%s" file(s) in "%s".\nDo they exist in the Data Folder?',upper(obj.EventFileParseMethod), obj.DataFolder)
               return
           end
           assert(~isempty(evID),'Failed to parse "%s"! \nIs this a valid Event file?',obj.EventFileName)
           % Check if the eventID has the same length as the timestamps:
           assert(isequaln(length(obj.timestamps), length(evID)), 'Failed to update events in file "%s". Event ID list must have the same length as the timestamps', obj.EventFileName)
           % Save event ID and name lists:
           obj.eventID = evID;
           obj.eventNameList = evNames;           
        end
                    
        function plotAnalogIN(obj, varargin)
            % PLOTANALOGIN plots the Analog input signals and overlays the
            % threshold as well as the detected triggers, if existent.
            %
            % Input (optional):
            %   chanName (char|cell): Channel name or list of names to
            %   plot. If not provided, all channels will de displayed.
            
            p = inputParser;
            addRequired(p,'obj');
            addOptional(p, 'chanName','',@(x) isempty(x) || all(ismember(lower(x),lower(obj.dictAIChan))));
            parse(p,obj,varargin{:});
            chanName = p.Results.chanName;            
            
            if isempty(obj.AnalogIN)
                return
            end
            
            if isempty(chanName)                
                chanName = obj.AIChanList;
            end
            
            if ischar(chanName)
                chanName = {chanName};
            end
                        
            [~,chanIndx] = ismember(chanName,obj.AIChanList);
            
            xVec = [0:size(obj.AnalogIN,1)-1]./obj.sr;% Use X-axis in seconds.
            axYSize = [min(obj.AnalogIN(:)), max(obj.AnalogIN(:))];
            % Show 4 plot per figure:
            nFigs = ceil(mod(length(chanName)/4,4));
            cnt = 1;   
            b_trigsPlotted= false;
            for ii = 1:nFigs
                f(ii) = figure('Name',sprintf('Analog Inputs %d/%d',ii,nFigs),...
                    'Visible','off','NumberTitle','off', 'Position',[0 0 560 720],...
                    'CreateFcn',{@movegui,'center'},'CloseRequestFcn', @closeAllFigs);                
                for jj = 1:4
                    if cnt > length(chanName)
                        break
                    end
                    s(cnt) = subplot(4,1,jj,'Parent',f(ii));
                    % Plot analogIN traces:
                    plot(s(cnt),xVec,obj.AnalogIN(:,chanIndx(cnt)),'ko-','MarkerSize',2, 'Color',[.8 .8 .8], 'MarkerEdgeColor','k');
                    if jj == 1
                        % Set axes labels:
                        s(cnt).XLabel.String = 'time (s)';
                        s(cnt).YLabel.String = 'amp.(V)';
                    end
                    % Plot detected triggers and threshold lines,
                    if ~b_trigsPlotted
                        hold(s(cnt),'on');
                        % Plot threshold line:
                        if ~ischar(obj.trigThr)
                            ln = line([xVec(1) xVec(end)],[obj.trigThr obj.trigThr],'Color','r');
                            ln.Tag = 'thrLn';
                        end
                        % Plot Trigger patches:
                        if ~isempty(obj.timestamps)
                            idx = unique(obj.eventID);
                            % Create semi-transparent patches to represent HIGH state of triggers:                          
                            % Trigger color code
                            colorArr = jet(64);
                            colorArr = colorArr(round(linspace(1,64,numel(obj.eventNameList))),:);
                            for kk = 1:length(idx)
                                xOn = obj.timestamps(obj.eventID == idx(kk) & obj.state == 1);
                                xOff = obj.timestamps(obj.eventID == idx(kk) & obj.state == 0);
                                x = [xOn xOff xOff xOn];
                                y = repmat([axYSize(1) axYSize(1) axYSize(2) axYSize(2)], size(xOn));
                                ptc(kk) = patch(s(cnt), x',y',colorArr(kk,:), 'FaceAlpha', .5, 'EdgeColor', 'none', 'Tag','TrigPatch');
                            end
                            % Put legend on the first plot:
                            if jj == 1
                                legend(s(cnt),ptc,obj.eventNameList,'Location','best')
                            end
                        end
                        hold(s(cnt),'off');
                    else
                        % copy the content of the first axis
                        if exist('ln','var')
                            copyobj(ln,s(cnt));
                        end
                        if exist('ptc','var')
                            copyobj(ptc,s(cnt));
                        end
                    end                    
                    title(s(cnt), chanName{cnt});
                    cnt = cnt+1;                    
                end                
            end
                        
            for ii = 1:length(f)
                f(ii).UserData = f;
                f(ii).Visible = 'on';
            end
            % Link all axes together
            linkaxes(s,'xy');
            set(s(1),'YLim',axYSize);
            
            % CloseFig callback:
            function closeAllFigs(src,~)
                % CLOSEALLFIGS closes all figures when the selected figure is closed.
                h = src.UserData;
                delete(h)
            end            
        end
        
        function getTriggers(obj)
            % GETTRIGGERS detects the triggers from one or more analog IN channels 
            %   with names stored in the "trigChanName" property.
            % It records the timestamps and state of each event.                         
% 
%             if ~isempty(obj.timestamps)
%                 warning('Event triggers already detected! Trigger detection aborted.');
%                 return
%             end
            if isempty([obj.trigChanName{:}])
                warning('Trigger channel name not set! Trigger detection aborted.')
                return
            end
            % Reset event info:
            obj.timestamps = [];
            obj.state = [];
            obj.eventID = [];
            obj.eventNameList = {};            
            for ii = 1:length(obj.trigChanName)
                idxCh = strcmpi(obj.trigChanName{ii},obj.AIChanList);
                if ~any(idxCh)
                    warning(['Channel ' obj.trigChanName{ii} ' not found!'])
                    continue
                end
                [tmstmp,chanState] = obj.detectTrig(obj.AnalogIN(:,idxCh));               
                obj.timestamps = [obj.timestamps;tmstmp];
                obj.state = [obj.state;chanState];
                % Create dummy event ID:
                obj.eventID = [obj.eventID; ones(length(tmstmp),1).*ii];
                % Control for failed detections:
                if isempty(obj.timestamps)
                    warning(['Failed to detect triggers in channel "' obj.trigChanName{ii} '".'])
                else
                    disp(['Triggers detected in channel "' obj.trigChanName{ii} '".']);
                end
                % Special Case: For internal analog triggers, use the
                % "Name" field of the channel instead of the channel ID.
                if startsWith(obj.trigChanName{ii}, 'StimAna')
                    num = erase(obj.trigChanName{ii}, 'StimAna');                   
                    try
                        obj.eventNameList{ii} = obj.AcqInfo.(['Stimulation' num '_Name']);
                    catch
                        %%% Do Nothing
                    end
                else
                    obj.eventNameList{ii}= obj.trigChanName{ii};
                end
            end 
            if isempty(obj.timestamps)                
                return
            end                
            [obj.timestamps,indx] = sort(obj.timestamps);
            obj.state = obj.state(indx);
            obj.eventID = obj.eventID(indx);
            
            % For digital stimulation, update event ID and event Name lists:                        
            if obj.b_isDigital
                % Overwrite dummy eventIDs with real ones from the info.txt.
                obj.eventID = ones(size(obj.state));
                obj.eventID(obj.state == 1) = obj.AcqInfo.Events_Order;
                obj.eventID(obj.state == 0) = obj.AcqInfo.Events_Order;
                fn = regexp(fieldnames(obj.AcqInfo),'Stim\d+','match','once');
                fn(cellfun(@isempty,fn)) = [];
                IDs = cellfun(@(x) obj.AcqInfo.(x).ID,fn);
                Names = cellfun(@(x) obj.AcqInfo.(x).Name,fn, 'UniformOutput',false);
                [~,idx] = sort(IDs);
                obj.eventNameList = Names(idx);
                disp('Trigger timestamps generated.');
            else                
                % For Analog stimulation with event list from text file, update
                % eventID and eventNameList:
                if ~isempty(obj.EventFileName)
                    switch lower(obj.EventFileParseMethod)
                        case 'default'
                            [obj.eventID, obj.eventNameList] = obj.readCSVfile;
                        case 'vpixx'
                            [obj.eventID, obj.eventNameList] = obj.readVpixxFile;
                        otherwise
                            error(['Unknown event file parsing method ' obj.EventFileParseMethod]);
                    end
                    % Repeat each event ID item to account for the offset (state == 0)
                    if length(obj.eventID) < length(obj.state)
                        obj.eventID = repelem(obj.eventID,2);
                    end
                    disp(['Event ID list read from file "' obj.EventFileName '"']);
                end
            end
            % Validate triggers:
            % Checks for equality of lengths of eventID and timestamps
            errID = 'Umitoolbox:EventsManager:IncompatibleArraySizes';
            msg = 'IncompatibleArraySizes: eventID and timestamps must have the same length.';
            assert(isequal(length(obj.eventID), length(obj.state), length(obj.timestamps)), errID, msg)
            % Check if the number of elements in eventNameList:
            if ~isempty(obj.eventNameList)
                msg = 'The unique values of eventID do not match the number of elements in eventNameList.';
                assert(isequal(numel(unique(obj.eventID)), numel(obj.eventNameList)), errID, msg);
            end
            % Display trigger stats:
            disp('Trigger detection completed.')
            disp('---------- Trigger info ----------')
            deltaT = [diff(obj.timestamps); nan];
            fprintf(['Total number of triggers: %d\nTotal number of conditions: %d\n' ...
                'Average trial length (HIGH state): %0.3f s\nAverage inter-trial length (LOW state): %0.3f s\n'...
                'Trigger detection threshold: %0.2f v\nTrigger type: %s\n'],sum(obj.state),length(obj.eventNameList),...
                mean(deltaT(obj.state == 1), 'omitnan'), mean(deltaT(obj.state == 0), 'omitnan'), obj.trigThr, ...
                obj.trigType)
            disp('--------------------------------')                     
        end
        
        function saveEvents(obj,saveFolder)
            % SAVEEVENTS creates the file "events.mat" in the
            % SaveFolder. This file is used by umIT to split the data into
            % trials.
            
            if nargin < 2 
                % If no SaveFolder is provided, create the file in the
                % "DataFolder".
                saveFolder = obj.DataFolder;  
            end
            if isempty(obj.timestamps)
                warning('Unable to create events.mat file. No triggers found!')
                return
            end
            % Format event data:
            eventID = uint16(obj.eventID);%#ok
            timestamps = single(obj.timestamps);%#ok
            state = logical(obj.state);%#ok
            eventNameList = obj.eventNameList;%#ok
            % Flip arrays:
            if size(eventID,1) < size(eventID,2)%#ok
                eventID = eventID';%#ok
            end
            if size(timestamps,1) < size(timestamps,2)%#ok
                timestamps = timestamps';%#ok
            end
            if size(state,1) < size(state,2)%#ok
                state = state';%#ok
            end            
            % Save:
            save(fullfile(saveFolder, 'events.mat'), 'eventID', 'state', 'timestamps', 'eventNameList');
            disp(['Events MAT file saved in  ' saveFolder]);
        end
    end
    
    methods (Access = private)
        
        function setInfo(obj)
            % SETINFO calls the "ReadInfoFile.m" function or simply loads
            %   the AcqInfo.m file from the DataFolder and stores the
            %   structure in the "AcqInfo" property. In addition, it uses
            %   the information to update the properties: 
            %   "sr" and "trigChanName" (for internal triggers only).
            
            % Load existing info:
            if exist(fullfile(obj.DataFolder, 'AcqInfos.mat'), 'file')
                a = load(fullfile(obj.DataFolder, 'AcqInfos.mat'));
                obj.AcqInfo = a.AcqInfoStream;
            elseif exist(fullfile(obj.DataFolder, 'info.txt'),'file')
                % Read Info file:
                obj.AcqInfo = ReadInfoFile(obj.DataFolder);
            else
                warning(['Unable to read experiment metadata. The file "info.txt" is missing in folder "' obj.DataFolder '"'])
                return
            end
            fn = fieldnames(obj.AcqInfo);
            idxChan = startsWith(fn,'AICh', 'IgnoreCase',true);        
            if ~any(idxChan)
                % For retrocompatibility with older versions of the "info.txt" 
                %   file where the names of AIchannels are not set. Here, we 
                %   infer the names of the channels based on the total number of channels:    
                
                % Initiate list with the names of the CameraTrigger and internal
                % channels, then, 
                obj.AIChanList = cell(1,obj.AcqInfo.AINChannels);
                switch obj.AcqInfo.AINChannels
                    case 1
                        % Cage system: 
                        obj.AIChanList(1) = {'CameraTrig'};                        
                        idx = 2;
                    case {2,6,10}
                        % Cage (n=2) or OiS200 (n=6,10) system. Camera and single internal trigger:
                        obj.AIChanList(1:2) = {'CameraTrig', 'StimAna1'};                                                                  
                        idx = 3;
                    case {3,7,11}
                        % Cage (n=3) or OiS200 (n=7,11) system. Camera and double internal triggers:
                        obj.AIChanList(1:3) = {'CameraTrig', 'StimAna1', 'StimAna2'};                                                                                                              
                        idx = 4;
                    otherwise
                        error('Failed to infer channel names from "info.txt" file!')
                end
                for ii = 0:obj.AcqInfo.AINChannels-idx
                    % Fill the rest of the channel names with the analog IN
                    obj.AIChanList{ii+idx} = ['AI', num2str(ii+1)];
                end
                % Add fields to AcqInfo property:
                for ii = 1:length(obj.AIChanList)
                    obj.AcqInfo.(['AICh' num2str(ii)]) = obj.AIChanList{ii};
                end
            else                
                obj.AIChanList = cellfun(@(x) obj.AcqInfo.(x),fn(idxChan),'UniformOutput',false);
            end
            
            % Validate if the list of channel names match the number of
            % channels:
            assert(isequaln(length(obj.AIChanList),obj.AcqInfo.AINChannels),...
                'Mismatch found between list of channel names and total number of channels! Check "info.txt" file!')
            % Validate if all AnalogIN names exist in the dictionary. (This
            %   will keep devs up-to-date on changes in the "info.txt" file)
            assert(all(ismember(lower(obj.AIChanList), lower(obj.dictAIChan))),'Unexpected AnalogIN channel name found in "info.txt" file!');            
            % Update Analog input sample rate:
            obj.sr = obj.AcqInfo.AISampleRate;
            
            % Update trigger names:            
            if any(startsWith(fn,'event','IgnoreCase',true))
                % For digital stimulation:
                obj.b_isDigital = true;
                obj.trigChanName = 'StimDig';
                return
            end
            % Update trigger names for Analog Stims:
            b_hasStim1 = any(cellfun(@any,regexpi(fn,'stimulation1_')));
            b_hasStim2 = any(cellfun(@any,regexpi(fn,'stimulation2_')));                            
            if ~any([b_hasStim1, b_hasStim2])
                return
            end
            names = {'StimAna1','StimAna2'};                
            obj.trigChanName = names([b_hasStim1, b_hasStim2]);            
            % Use the pulse information from analog stim to update the
            % minimal interStim interval for detection of bursts stim.
            % blocks. We set the minimal interstim as the largest pulse
            % interstim with an extra 15%.
            idxBurst = contains(fn,'burst_delay','IgnoreCase',true);
            idxPeriod = contains(fn,'_period','IgnoreCase',true);
            idxFreq = contains(fn,'_frequency','IgnoreCase',true);
            if any(idxBurst) && obj.AcqInfo.(fn{find(idxBurst,1,'first')}) > 0
                % Use burst delay 
                burst_delay = obj.AcqInfo.(fn{find(idxBurst,1,'first')});
                stim_period = obj.AcqInfo.(fn{find(idxPeriod,1,'first')});
                obj.minInterStim = 1.15*(burst_delay + stim_period)/1000; % Add 15% to the value of the burst delay                
            elseif any(idxPeriod)
                % Use the pulse period
                obj.minInterStim = 1.15*(obj.AcqInfo.(fn{find(idxPeriod,1,'first')}))/1000;% Add 15% to the value of the pulse period
            else
                % Calculate the pulse period from frequency (older
                % "info.txt" versions)
                obj.minInterStim = 1.15*(1/obj.AcqInfo.(fn{find(idxFreq,1,'first')}));% Add 15% to the value of the pulse period                
            end

        end
        
        function setAnalogIN(obj)
            % SETANALOGIN reads the ai_xxxx.bin files and saves it in "AnalogIN" property.
            % List of analog files containing raw data:
            
            aiFilesList = dir(fullfile(obj.DataFolder,'ai_*.bin'));
            if isempty(aiFilesList)
                warning(['Analog Input files (ai_xxxx.bin) not found in "' obj.DataFolder '"'])
                return
            end            
            disp('Reading analog inputs...')
            % Opening of the files:
            obj.AnalogIN = [];
            for ind = 1:size(aiFilesList,1)
                data = memmapfile(fullfile(obj.DataFolder,aiFilesList(ind).name),...
                    'Offset', 5*4, 'Format', 'double', 'repeat', inf);
                tmp = data.Data;
                tmp = reshape(tmp, 1e4, obj.AcqInfo.AINChannels, []);
                tmp = permute(tmp,[1 3 2]);
                tmp = reshape(tmp,[],obj.AcqInfo.AINChannels);
                obj.AnalogIN = [obj.AnalogIN; tmp];
            end
            % Crop to first and last camera triggers:
            camT = diff(obj.AnalogIN(:,1) > 2.5); camT = [camT;NaN];
            camTOn = find(camT == 1,1,'first');
            camTOff = find(camT == -1,1,'last');
            obj.AnalogIN = obj.AnalogIN(camTOn:camTOff,:);
            disp('Done')
        end
                     
        function [timestamps, state] = detectTrig(obj,data)
            % DETECTTRIG detects the triggers from a given signal and
            %   outputs the timestamps and state. THis function is called by
            %   the method "getTriggers".            
            % Input:
            %    data(1xN num. vector): vector containing the triggers.
            % Outputs:
            %    timestamps (num vect.): time delay (in seconds) of triggers detected.
            %    state (num vect.): state of the trigger: 1 = rising; 0 = falling.
            
            timestamps = single.empty();
            state = uint8.empty();
            % Check if "data" is a vector;
            validateattributes(data,{'single','double'},{'vector'});
            %
            if size(data,1) > size(data,2)
                data = data';
            end
            if strcmpi(obj.trigThr, 'auto')
                trigAmp = (.8*(max(data(:)) - min(data(:))));
                % Control for the minimal amplitude for trigger detection
                if trigAmp < obj.minTrigAmp
                    warning('Operation Aborted! The trigger amplitude is too low for automatic detection! Manually set a threshold and try again.');
                    return
                end
                % Update trigger threshold value:
                obj.trigThr = trigAmp + min(data(:));
            end
            
            % Find samples that cross the threshold (rising and falling):            
            tmRise = find(data < obj.trigThr & [data(2:end) nan] > obj.trigThr);
            tmFall = find(data > obj.trigThr & [data(2:end) nan] < obj.trigThr);            
            if isempty(tmRise)                
                return
            elseif numel(tmRise) ~= numel(tmFall)
                % Need to decide what to do in this case. For now, throw a
                % warning.
                warning('Number of rising and falling edges are not equal!')
                return
            end
            timestamps = single([tmRise tmFall]./obj.sr);
            state = [ones(1,numel(tmRise), 'uint8') zeros(1,numel(tmFall), 'uint8')];
            % Sort arrays by time and flip:
            [timestamps,idx] = sort(timestamps);
            timestamps = timestamps';
            state = state(idx)';
            % For Toggle type triggers:
            if strcmpi(obj.trigType, 'edgetoggle')                
                % Use 2nd signal onset as the trial "OFF" state:
                timestamps = timestamps(state==1);
                % Overwite state:
                state = ones(sum(state),1,'uint8');
                state(2:2:end) = 0;
            end
            
            % Deal with bursts stimuli:
            StimLim = find(diff(timestamps(state ==1)) >= obj.minInterStim); %             
            NbStim = length(StimLim)+1;
            if NbStim < sum(state) && ~obj.b_isDigital
                disp('Burst stim detected.')                                                  
                BurstOff = [StimLim; length(tmFall)]; 
                BurstOn = [1; StimLim+1];
                % Update timestamps and state:                
                tmRise = tmRise(BurstOn);
                tmFall = tmFall(BurstOff); 
                % Recalculate the timestamps and state:
                timestamps = single([tmRise tmFall]./obj.sr);
                state = [ones(1,numel(tmRise), 'uint8') zeros(1,numel(tmFall), 'uint8')];
                % Sort arrays by time and flip:
                [timestamps,idx] = sort(timestamps);
                timestamps = timestamps';
                state = state(idx)';
            end                 
            % Update timestamps and states for digital stim. Digital stim
            %   will only have a toggle marking the stim onset and the
            %   duration (in seconds) is recorded in the "info.txt" file.
            if obj.b_isDigital                
                fn = regexp(fieldnames(obj.AcqInfo),'Stim\d+','match','once');
                fn(cellfun(@isempty,fn)) = [];  
                stimInfo = cellfun(@(x) obj.AcqInfo.(x), fn);
                durationMap = containers.Map([stimInfo.ID],[stimInfo.Duration]);
                durationOrder = arrayfun(@(x) durationMap(x), obj.AcqInfo.Events_Order);                
                timestamps = reshape([timestamps(state == 1)'; timestamps(state ==1)' + durationOrder],numel(state),[]); % Create timestamps to mark the end of the stim (trigger + duration_sec);               
            end                       
        end
        
        %%%%% Event File parsers %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                
        function [eventID, eventNameList] = readCSVfile(obj, colName)
            % READCSVFILE reads a .CSV file. If no column name is provided,
            % it reads the content of the first column and considers it
            % without header. If one column name is provided, it reads the
            % rows of the given column. If 2 or more column names are
            % provided, the values of the column names are concatenated
            % with a hiphen ("-"). 
            % Input:
            %    colName(optional, char|cell): column name(s) to be read
            %    from the CSV file.
            % Outputs:
            %    eventID (num vect.): list of indices of the events listed
            %    in "eventNameList".
            %    eventNameList (cell): list of event names in alphabetical
            %    order.            
            % Set CSV reading rules:                       
            opts = detectImportOptions(obj.EventFileName);
            if ~isempty([colName{:}])
                opts.SelectedVariableNames = colName; % Select the input columns only.
            else
                colName = opts.VariableNames;
            end            
%             opts.DataLines = 2; %Start reading at 2nd row.
            opts.VariableTypes = repmat({'char'},size(opts.VariableTypes)); % Force data to characters.
            opts.MissingRule = 'omitrow'; % Remove rows with missing values.
            opts.ExtraColumnsRule = 'ignore'; % Ignore empty columns.
            % Read .CSV file:
            out = table2cell(readtable(obj.EventFileName,opts));                        
            % Merge multiple columns into a single one:
            nameList = cell(size(out,1),1);            
            for ii = 1:size(out,1)                
                    nameList{ii} = strjoin(reshape(vertcat(colName,out(ii,:)),1,[]),'-');
            end            
            eventNameList = unique(nameList);%             
            nameMap = containers.Map(eventNameList,1:length(eventNameList)); 
            eventID = zeros(length(nameList),1);
            for ii = 1:length(nameList)
                % Generate event ID from event name index.
                eventID(ii) = nameMap(nameList{ii});
            end 
            % Duplicate the eventID to account for low state (considering
            % that there is no overlap between conditions).
            eventID = repelem(eventID,2);
        end
        
        function [eventID, eventNameList] = readVpixxFile(obj)
            % READVPIXXFILE extracts the condition ID, name and timestamps (if applicable)
            %   from the RAW DATA section of a .txt or .vpixx file.
            % Outputs:
            %    eventID (num vect.): list of indices of the events listed
            %    in "eventNameList".
            %    eventNameList (cell): list of event names in alphabetical
            %    order. 
            
            % Extract only the part of the text containing the real sequence of
            %   conditions (RAW DATA section):
            filetext = fileread(obj.EventFileName);
            [~,idx_start] = regexp(filetext, 'RAW DATA');
            idx_stop = regexp(filetext, 'SORTED');            
            filetext = strip(filetext(idx_start+1:idx_stop-1));
            if isempty(filetext)
                return
            end
            tab = strsplit(filetext, '\n')';
            % Get stimulus ID and order. Ignore Event and Time columns for now!
            out = {};
            myCols = [2 3]; % Keep just Condition and Stimulus.
            for i = 2:length(tab)
                str = strsplit(tab{i},'\t');
                if isempty(str{1})
                    % Skip Event rows.
                    continue
                end
                out = [out;str(myCols)];
            end            
            out(:,1) = cellfun(@str2double, out(:,1), 'UniformOutput',false);
            eventID = [out{:,1}]';            
            IDs = unique(eventID);
            eventNameList = cell(length(IDs),1);            
            for ii = 1:length(IDs)
                idx = find(eventID == IDs(ii),1,'first');
                eventNameList(ii) = out(idx,2);
            end
            % Duplicate the eventID to account for low state (considering
            % that there is no overlap between conditions).
            eventID = repelem(eventID,2);
        end
                
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                        
        function delete(obj)
            % Class destructor. Re-enables original warnings.
            warning(obj.warnOrigState)
        end
    end
end


