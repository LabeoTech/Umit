classdef EventsManager < handle
    % EVENTSMANAGER. A class to manage triggers and meta data (event IDs and names)
    %   in order to create an "events.mat" file to be used by umIT. This
    %   class deals exclusively with data generated by LabeoTech imaging
    %   systems (e.g. OiS200).
    properties
        trigThr = 'auto'; % Trigger detection Threshold in volts (Default = 'auto'). The 'auto' means that the threshold will be at 70% of the signal amplitude.
        trigType char = 'EdgeSet' % Trigger type.
        trigChanName = {''}; % Name of AI channel(s) containing the triggers.
        minInterStim single {mustBeNonnegative} = 2 % Minimal inter stim time (in seconds). This param. is used to identify Bursts in analogIN. !This value should be higher than the inter-burst value to work!
        RawFolder char % Folder containing the ai_xxxx.bin and (optionally) the Event list file.
    end
    properties (SetAccess = private)
        dictAIChan cell = {'CameraTrig', 'CameraTrig2', 'InputTrigger',...
            'StimAna1','StimAna2', 'StimDig', 'Optogen', 'Unused',...
            'AI1', 'AI2','AI3','AI4','AI5','AI6','AI7','AI8'}; %  List of all available channels from Imaging system:
        AIChanList cell % List of Analog IN channels obtained from "AcqInfo".
        SaveFolder char % Folder containing the "AcqInfos.mat" file. Default folder to save/load the "events.mat" file.
        AcqInfo struct % Content of the info.txt file as a structure.
        AnalogIN single % Array of analog input data.
        sr single {mustBePositive} = 10000; % Sample rate of analog input channels in Hz.
        timestamps single {mustBeNonnegative} % Time stamps in seconds of triggers.
        state logical {mustBeNonnegative} % State of triggers (1= ON, 0 = OFF)
        eventID uint16 {mustBePositive} % Index of each condition (1, 2, 3 ...)
        eventNameList cell % Name of each condition.
        baselinePeriod single{mustBePositive} % Trial baseline duration (in seconds) for splitting data by trials.
        selectedEvents logical % Matrix (Event by Repetition) of repetitions to be used when splitting the data by trials (TRUE = keep;FALSE = ignore).
        b_isDigital logical = false; % TRUE for digital stimulation using OiS200 as master.
        minTrigAmp single {mustBePositive} = .15; % Minimal signal amplitude (in Volts). Used when the trigger threshold is "auto". Ignored otherwise.
        EventFileName char % Name of the event file containing events information (.csv, .txt, .vpixx ...).
    end
    properties (Access = private)
        warnOrigState % original state of Matlab's warnings. This will be restored at this class destruction.
        ParseMethods = {'none','csv','vpixx'}; % List of valid parse methods.
        privateEventFileParseMethod;
        b_LP_applied = false % Boolean to indicate if a low-pass filtering was applied to the AnalogIN data.
    end
    properties (Dependent)
        EventFileParseMethod char % Name of the method to read the Event File. {'CSV','vpixx'};
    end
    
    methods
        function obj = EventsManager(varargin)
            % This is the constructor method.
            % It instantiates the object and sets the values for the
            % DataFolder and EventFileName properties.
            % It reads the analog IN channels and the info.txt as well.
            % Inputs:
            %   RawFolder (char): path to the folder containing the
            %       ai_xxxx.bin data and "info.txt" file. If not provided,
            %       load an "events.mat" file or manually set the
            %       RawFolder later.
            %   SaveFolder (char): path to the folder containing the
            %       AcqInfos.mat file. This will be the folder where the
            %       "events.mat" file will be saved or loaded from.
            %   ParseMethod (optional, char): Name of the parsing method to
            %   apply to the event file containing the list of event
            %   IDs:{'none'(default),'csv','vpixx'}.
            
            % Input validation:
            p = inputParser;            
            addOptional(p,'SaveFolder',pwd,@isfolder)
            addOptional(p,'RawFolder','',@ischar)
            addOptional(p, 'ParseMethod','csv',@(x) ismember(lower(x),obj.ParseMethods));
            parse(p,varargin{:});
            
            % Disable backtrace warnings:
            obj.warnOrigState = warning;
            warning('off', 'backtrace');
            
            % Set main properties:            
            obj.SaveFolder = p.Results.SaveFolder;
            obj.RawFolder = p.Results.RawFolder;
            obj.EventFileParseMethod = lower(p.Results.ParseMethod);
            % Set properties based on the AcqInfo.mat file:
            try
                obj.setInfo;
            catch
                warning('The folder "%s" does not contain the "AcqInfos.mat" file. Set a valid DataFolder or load an "events.mat" file.',obj.SaveFolder);
                return
            end
            % Set AnalogIN property:
            %             obj.setAnalogIN;
            %             % Detect internally-generated triggers:
            %             if ~isempty([obj.trigChanName{:}])
            %                 obj.getTriggers;
            %             end
            % Force EventFileParseMethod to "none" if the stimulus is
            % digital. In this case, the event info should already be
            % stated in the "info.txt" file (to be confirmed)
            if obj.b_isDigital && ~strcmpi(obj.EventFileParseMethod, 'none')
                warning('Event file parsing method set to "none" because the stimulus is digital.')
                obj.EventFileParseMethod = 'none';
            end
        end
        
        function set.EventFileParseMethod(obj, parseMethod)
            % Set method for event file parse method. Just checks if the
            % input is valid. Valid parsing methods are stored in the
            % property "ParseMethods".
            
            parseMethod = lower(convertStringsToChars(parseMethod));
            validateattributes(parseMethod,{'char'},{'scalartext'}, 'set.EventFileParseMethod');
            msg = [sprintf('Invalid parse method "%s". It must be one of the following:',parseMethod),...
                sprintf('\n%s',obj.ParseMethods{:})];
            assert(ismember(parseMethod,obj.ParseMethods),msg);
            obj.privateEventFileParseMethod = parseMethod;
        end
        
        function set.trigChanName(obj, trigName)
            % Set method for trigger channel name.
            % Forces the property to a cell.
            if ischar(trigName)
                obj.trigChanName = {trigName};
            elseif iscell(trigName)
                obj.trigChanName = trigName;
            else
                error(['Format ' class(trigName) ' not supported! It must be char or cell array of chars.'])
            end
        end
        
        function set.trigType(obj, trigType)
            assert(ismember(lower(trigType), {'edgeset','edgetoggle'}),'Invalid trigger type! It must be either "EdgeSet" or "EdgeToggle".')
            obj.trigType = lower(trigType);
        end
        
        function setBaselinePeriod(obj,baselinePeriod)
            % Sets the baseline period (pre-event onset time) property with 
            % for trial splitting. The user can manually set the baseline period.
            % If not, this period will correspond to 20% of the trial length.
            %
            % Parameters:
            %   baseline_period (scalar): The time period before the event onset.
            %
            % Example:
            %   obj.setBaselinePeriod(); % Uses default values
            %   obj.setBaselinePeriod(2) % Sets the preEventTime to 2s and
            %       use the remainder of the total trial length as the
            %       postEvent time.
            
            % Check for triggers:
            assert(~isempty(obj.state), 'Failed to set trial interval! No triggers detected yet!')
            % Abort, if the data in the SaveFolder was previously cropped:
            if isfield(obj.AcqInfo, 'bDataTrimmed')
                if obj.AcqInfo.bDataTrimmed
                    warning('Operation aborted! Baseline period was already set! Re-import the data and try again.');
                    return
                end
            end
            % Validate baseline period:            
            tm_on = obj.timestamps(obj.state);
            trial_length = diff(tm_on);
            if ~exist('baselinePeriod','var')
                % Set baseline duration as 20% of the minimal total trial
                % length:
                baselinePeriod = 0.2*(min(trial_length));
            else
                % Check if the user-defined baseline period is valid
                % following the criteria below:
                %   1) Is not larger than the trial length minus a frame.
                %   2) Is not smaller than a single frame.
                % This is to avoid frames falling in two consecutive trials
                % (overlapping trials).
                max_baseline_allowed = min(diff(tm_on) - 1/obj.AcqInfo.FrameRateHz);
                % Criterion 1):
                assert(baselinePeriod < max_baseline_allowed,...
                    'Baseline time period is too long! It must be shorter than %0.2f seconds!',max_baseline_allowed);
                % Criterion 2):
                assert(baselinePeriod >= 1/obj.AcqInfo.FrameRateHz,...
                    'Baseline time period is too short! It must be larger than %0.2f seconds!',1/obj.AcqInfo.FrameRateHz);
            end
            % Update baseline period value
            obj.baselinePeriod = baselinePeriod;
            fprintf('Baseline period set to %0.2f seconds.\n',obj.baselinePeriod)            
        end
        
        function setAnalogIN(obj)
            % SETANALOGIN reads the ai_xxxx.bin files and saves it in "AnalogIN" property.
            % List of analog files containing raw data:
            
            aiFilesList = dir(fullfile(obj.RawFolder,'ai_*.bin'));
            if isempty(aiFilesList)
                warning(['Analog Input files (ai_xxxx.bin) not found in "' obj.RawFolder '"'])
                return
            end
            % Check if the AcqInfos structure exists:
            if isempty(obj.AcqInfo)
                obj.setInfo;
            end
            disp('Reading analog inputs...')
            % Opening of the files:
            obj.AnalogIN = [];
            for ind = 1:size(aiFilesList,1)
                data = memmapfile(fullfile(obj.RawFolder,aiFilesList(ind).name),...
                    'Offset', 5*4, 'Format', 'double', 'repeat', inf);
                tmp = data.Data;
                tmp = reshape(tmp, 1e4, obj.AcqInfo.AINChannels, []);
                tmp = permute(tmp,[1 3 2]);
                tmp = reshape(tmp,[],obj.AcqInfo.AINChannels);
                obj.AnalogIN = [obj.AnalogIN; tmp];
            end
            % Crop to first and last camera triggers:
            camT = diff(obj.AnalogIN(:,1) > 2.5); camT = [camT;NaN];
            camTOn = find(camT == 1,1,'first');
            camTOff = find(camT == -1,1,'last');
            obj.AnalogIN = obj.AnalogIN(camTOn:camTOff,:);
            disp('Done')
        end
        
        function out = get.EventFileParseMethod(obj)
            out = obj.privateEventFileParseMethod;
        end
                       
        function getTriggers(obj, varargin)
            % GETTRIGGERS detects the triggers from one or more analog IN channels
            %   with names stored in the "trigChanName" property.
            % It records the timestamps and state of each event.
            % Input:
            %   b_verbose(bool, default = FALSE): If TRUE, displays some basic stats on
            %   trigger detection on the command window.
            %
            p = inputParser;
            addRequired(p,'obj');
            addOptional(p,'ChannelName','',@(x) ischar(x) || iscellstr(x) || isstring(x));
            addOptional(p,'b_verbose',true,@islogical)
            addParameter(p,'FilterFreq',0,@(x) isscalar(x) & x>=0)
            parse(p,obj,varargin{:})
            chanName = convertStringsToChars(p.Results.ChannelName);
            b_verbose = p.Results.b_verbose;
            FilterFreq = p.Results.FilterFreq;
            
            if ~isempty(chanName)
                obj.trigChanName = chanName;
            elseif isempty(chanName) && isempty([obj.trigChanName{:}])
                warning('Trigger channel name not set! Trigger detection aborted.')
                return
            end
            if isempty(obj.AnalogIN)
                % Read AnalogIN data:
                obj.setAnalogIN;
            end
            if ( FilterFreq > 0 && FilterFreq < obj.sr/2 )
                % Apply low-pass filter to the data at selected cut-off
                % frequency:
                f = fdesign.lowpass('N,F3dB', 4, FilterFreq, obj.sr); %Fluo lower Freq
                lpass = design(f,'butter');
                obj.b_LP_applied = true;
            end
            
            if obj.b_LP_applied
                % Reset AnalogIN data to original, if a filtering was
                % already applied.
                obj.setAnalogIN;
                obj.b_LP_applied = false;
            end
            % Reset event info:
            obj.timestamps = [];
            obj.state = [];
            obj.eventID = [];
            obj.eventNameList = {};
            
            % Get triggers:
            for ii = 1:length(obj.trigChanName)
                idxCh = strcmpi(obj.trigChanName{ii},obj.AIChanList);
                if ~any(idxCh)
                    warning(['Channel ' obj.trigChanName{ii} ' not found!'])
                    continue
                end
                if FilterFreq
                    % Apply low-pass filter to the data at selected cut-off
                    % frequency:
                    obj.AnalogIN(:,idxCh) = single(filtfilt(lpass.sosMatrix, lpass.ScaleValues, double(obj.AnalogIN(:,idxCh))')');
                end
                [tmstmp,chanState] = obj.detectTrig(obj.AnalogIN(:,idxCh));
                % Control for failed detections:
                if isempty(tmstmp)
                    warning(['Failed to detect triggers in channel "' obj.trigChanName{ii} '".'])
                    continue
                else
                    disp(['Triggers detected in channel "' obj.trigChanName{ii} '".']);
                end
                
                obj.timestamps = [obj.timestamps;tmstmp];
                obj.state = [obj.state;chanState];
                % Create dummy event ID:
                obj.eventID = [obj.eventID; ones(length(tmstmp),1).*ii];
                
                % Special Case: For internal analog triggers, use the
                % "Name" field of the channel instead of the channel ID.
                num = erase(obj.trigChanName{ii}, 'StimAna');
                if startsWith(obj.trigChanName{ii}, 'StimAna') && isfield(obj.AcqInfo, ['Stimulation' num '_Name'])
                    obj.eventNameList{ii} = obj.AcqInfo.(['Stimulation' num '_Name']);
                else
                    obj.eventNameList = [obj.eventNameList, obj.trigChanName(ii)];
                end
            end
            if isempty(obj.timestamps)
                return
            end
            [obj.timestamps,indx] = sort(obj.timestamps);
            obj.state = obj.state(indx);
            obj.eventID = obj.eventID(indx);
            
            % For digital stimulation, update event ID and event Name lists:
            if obj.b_isDigital
                % Overwrite dummy eventIDs with real ones from the info.txt.
                obj.eventID = ones(size(obj.state));
                obj.eventID(obj.state == 1) = obj.AcqInfo.Events_Order;
                obj.eventID(obj.state == 0) = obj.AcqInfo.Events_Order;
                fn = regexp(fieldnames(obj.AcqInfo),'Stim\d+','match','once');
                fn(cellfun(@isempty,fn)) = [];
                IDs = cellfun(@(x) obj.AcqInfo.(x).ID,fn);
                Names = cellfun(@(x) obj.AcqInfo.(x).Name,fn, 'UniformOutput',false);
                [~,idx] = sort(IDs);
                obj.eventNameList = Names(idx);
                disp('Trigger timestamps generated.');
            end
            % Validate triggers:
            % Checks for equality of lengths of eventID and timestamps
            errID = 'Umitoolbox:EventsManager:IncompatibleArraySizes';
            msg = 'IncompatibleArraySizes: eventID and timestamps must have the same length.';
            assert(isequal(length(obj.eventID), length(obj.state), length(obj.timestamps)), errID, msg)
            % Check if the number of elements in eventNameList:
            if ~isempty(obj.eventNameList)
                msg = 'The unique values of eventID do not match the number of elements in eventNameList.';
                assert(isequal(numel(unique(obj.eventID)), numel(obj.eventNameList)), errID, msg);
            end
            % Display trigger stats:
            if b_verbose
                disp('Trigger detection completed.')
                disp('---------- Trigger info ----------')
                deltaT = [diff(obj.timestamps); nan];
                fprintf(['Total number of triggers: %d\nTotal number of conditions: %d\n' ...
                    'Average trial length (HIGH state): %0.3f s\nAverage inter-trial length (LOW state): %0.3f s\n'...
                    'Trigger detection threshold: %0.2f v\nTrigger type: %s\n'],sum(obj.state),length(obj.eventNameList),...
                    mean(deltaT(obj.state == 1), 'omitnan'), mean(deltaT(obj.state == 0), 'omitnan'), obj.trigThr, ...
                    obj.trigType)
                disp('--------------------------------')
            end
            obj.clearIgnoredEvents; % Reset lists of ignored Condition and Repetitions
            % Try to set baseline period:
            if isempty(obj.baselinePeriod)
                obj.setBaselinePeriod;
            end
        end
        
        function f = plot(obj, chanName)
            % PLOTANALOGIN plots the Analog input signals and overlays the
            % threshold as well as the detected triggers, if existent.
            %
            % Input (optional):
            %   chanName (char|cell): Channel name or list of names to
            %   plot. If not provided, all channels will de displayed.
            % Output (optional):
            %   f (handle): array of figure handle(s).
            if isempty(obj.AnalogIN)
                warning('No signal to plot!')
                return
            end
            
            if ~exist('chanName','var') || isempty(chanName)
                % plot All channels if no channel name is provided:
                chanName = obj.AIChanList;
            end
            
            if ischar(chanName)
                chanName = {chanName};
            end
            % Check inputs:
            b_chanExists = ismember(chanName,obj.dictAIChan);
            if all(~b_chanExists)
                error(['Invalid channel name(s). It must be one of the following:',sprintf('\n"%s"',obj.dictAIChan{:})]);
            elseif any(~b_chanExists)
                warning(['The following channel(s) do not exist and will be ignored:', sprintf('\n"%s"',chanName{~b_chanExists})])
                chanName = chanName(b_chanExists);
            end
            [~,chanIndx] = ismember(chanName, obj.AIChanList);
            % Calculate the number of figures with a maximum of 4 subplots per figure:
            nFigs = ceil(length(chanIndx)/4);
            nAxPerFig = ones(1,nFigs)*4;
            remAx = mod(length(chanIndx),4);
            if remAx > 0
                nAxPerFig(end) = remAx;
            end
            cnt = 1;
            b_trigsPlotted= false;
            % Set axes properties:
            xVec = [0:size(obj.AnalogIN,1)-1]./obj.sr;% Use X-axis in seconds
            axYSize = [min(obj.AnalogIN(:)), max(obj.AnalogIN(:))]; % Get min-max for Yscale
            
            for ii = 1:nFigs
                f(ii) = figure('Name',sprintf('Analog Inputs %d/%d (downsampled to %0.0f KHz)',ii,nFigs, obj.sr/10000),...
                    'Visible','off','NumberTitle','off', 'Position',[0 0 560 nAxPerFig(ii)*200],...
                    'CreateFcn',{@movegui,'center'},'CloseRequestFcn', @closeAllFigs);
                for jj = 1:nAxPerFig(ii)
                    s(cnt) = subplot(nAxPerFig(ii),1,jj, 'Parent',f(ii));
                    s(cnt).XLabel.String = 'time (s)';
                    s(cnt).YLabel.String = 'amp.(V)';
                    % Plot analogIN traces (downsample to 1KHz to save space):
                    line(xVec(1:10:end),obj.AnalogIN(1:10:end,chanIndx(cnt)),'LineStyle','-', 'Color',[.3 .3 .3],'Parent',s(cnt));
                    if jj == 1
                        % Set axes labels:
                        s(cnt).XLabel.String = 'time (s)';
                        s(cnt).YLabel.String = 'amp.(V)';
                    end
                    % Plot detected triggers and threshold lines,
                    if ~b_trigsPlotted
                        hold(s(cnt),'on');
                        % Plot threshold line:
                        if ~ischar(obj.trigThr)
                            ln = line([xVec(1) xVec(end)],[obj.trigThr obj.trigThr],'Color','r');
                            ln.Tag = 'thrLn';
                        end
                        % Plot Trigger patches:
                        if ~isempty(obj.timestamps)
                            idx = unique(obj.eventID);
                            % Create semi-transparent patches to represent HIGH state of triggers:
                            % Trigger color code
                            colorArr = jet(64);
                            colorArr = colorArr(round(linspace(1,64,numel(obj.eventNameList))),:);
                            for kk = 1:length(idx)
                                xOn = obj.timestamps(obj.eventID == idx(kk) & obj.state == 1);
                                xOff = obj.timestamps(obj.eventID == idx(kk) & obj.state == 0);
                                x = [xOn xOff xOff xOn];
                                y = repmat([axYSize(1) axYSize(1) axYSize(2) axYSize(2)], size(xOn));
                                ptc(kk) = patch(s(cnt), x',y',colorArr(kk,:), 'FaceAlpha', .25, 'EdgeColor', 'none', 'Tag','TrigPatch');
                                uistack(ptc(kk), 'bottom');
                            end
                            % Put legend on the first plot:
                            if jj == 1
                                legend(s(cnt),ptc,obj.eventNameList,'Location','best', 'Interpreter','none');
                            end
                        end
                        hold(s(cnt),'off');
                        
                    else
                        % copy the content of the first axis
                        if exist('ptc','var')
                            
                            copyobj(ptc,s(cnt));
                        end
                        if exist('ln','var')
                            copyobj(ln,s(cnt));
                        end
                    end
                    title(s(cnt), chanName{cnt});
                    cnt = cnt+1;
                end
            end
            for ii = 1:length(f)
                % Cascade figures:
                if ii > 1
                    f(ii).Position([1 2]) = f(ii-1).Position([1 2]) + [25 -25];
                end
                f(ii).UserData = f;
                f(ii).Visible = 'on';
            end
            % Link all axes together
            linkprop(s,{'XLim','YLim'});
            set(s(1),'YLim',axYSize);
            
            % CloseFig callback:
            function closeAllFigs(src,~)
                % CLOSEALLFIGS closes all figures when the selected figure is closed.
                h = src.UserData;
                delete(h)
            end
        end
                        
        function status = readConditionFile(obj, varargin)
            % READCONDITIONFILE reads the content of an event file containing a
            % list of event Names. The file will be parsed using one of the
            % parsing methods available in this class (e.g., for .CSV,
            % .vpixx) and set by the "EventFileParseMethod" property. This
            % property is set at the class construction.
            % If the "EventFileName" is not provided, this function will
            % look for the file with the valid extension (.csv,
            % .vpixx) inside the "RawFolder" and parse it. Override this by
            % giving the full path of the "EventsFileName" as input.
            % For .CSV files, the list of events should be arranged in a
            % column with a HEADER (a header is necessary!) in the first row.
            % Multiple columns will be merged as a single event per row.
            % It is possible to select  a subset of columns by providing the
            % names of the columns "CSVcolNames" as input (Case sensitive!).
            %
            % Inputs (Optional):
            %   EventFileName (char): full path to a valid file containing
            %    the event IDs/Names to be parsed using the parse method set
            %    in the "EventFileParseMethod" property.
            %   CSVcolNames (cell): name of column(s) from a .CSV file to be
            %    read. If more than one column is provided, each row will
            %    be merged into a single one (this parameter is ignored for
            %    other parsing methods).
            % Output:
            %    status (bool): TRUE, if the event file was successfully
            %    read. FALSE otherwise.
            % Examples:
            %  1 - Automatic search for a .CSV file with a single column:
            %    readConditionFile();
            %  2 - Read an specific .CSV file:
            %    readConditionFile('C:/FULLPATH/FILENAME.CSV');
            %  3 - Read a subset of columns from a .CSV file:
            %    readConditionFile('CSVcolNames',{'Col1'',Col2','Col5'};
            %  4 - Read a subset o columns from an specific .CSV file:
            %    readConditionFile('C:/FULLPATH/FILENAME.CSV','CSVcolNames',{'ThisOne'});
            
            p = inputParser;
            addRequired(p,'obj')
            addOptional(p,'EventFileName','',@(x) ischar(x) | isempty(x));
            addParameter(p,'CSVcols',{''},@(x) iscell(x) & ischar([x{:}]));
            parse(p,obj,varargin{:});
            %
            evFile = p.Results.EventFileName;
            colNames = p.Results.CSVcols;
            %
            status = false;
            % Check if event file parsing method was set:
            if strcmpi(obj.EventFileParseMethod,'none')
                if ~isempty(evFile) || ~isempty(colNames{:})
                    warning('Operation aborted! EventFileParseMethod is not set yet.')
                end
                return
            end
            % Check if the trigger detection was already executed:
            if isempty(obj.eventID)
                warning('Operation aborted! Triggers missing. Detect triggers first, then read the event file to update the event IDs and names');
                return
            end
            if ~isempty(evFile)
                [folder,name,ext] = fileparts(evFile);
                if isempty(folder)
                    folder = obj.RawFolder;
                end
                if isempty(ext)
                    switch obj.EventFileParseMethod
                        case 'csv'
                            evFile = [name, '.csv'];
                        case 'vpixx'
                            if exist(fullfile(folder,[name, '.vpixx']),'file')
                                evFile = fullfile(folder,[name, '.vpixx']);
                            else
                                evFile = fullfile(folder,[name, '.txt']);
                            end
                        otherwise
                            error('Unknown file Parsing method')
                    end
                end
                
                % Check if the file exists. If not, raise a warning and
                % return:
                if ~exist(evFile,'file')
                    warning('Operation aborted. Events file "%s" does not exist!',evFile);
                    return
                end
                evFile = {evFile};
            else
                % For automatic detection of event files:
                fList = [dir(fullfile(obj.RawFolder,'*.csv'));...
                    dir(fullfile(obj.RawFolder,'*.vpixx'));...
                    dir(fullfile(obj.RawFolder,'*.txt'))];
                evFile = fullfile({fList.folder},{fList.name});
                if isempty([evFile{:}])
                    warning('Event list not found! Event IDs and names will not be updated!')
                    return
                end
            end
            % Try to parse files until it works:
            evID = []; evNames = {};
            for ii = 1:length(evFile)
                obj.EventFileName = evFile{ii};
                try % try-catch is here just to supress errors from private functions when non-event files are read. Errors or warnings will be raised here instead.
                    if strcmpi(obj.EventFileParseMethod,'csv') && endsWith(lower(obj.EventFileName), '.csv')
                        [evID, evNames] = obj.readCSVfile(colNames);
                    elseif strcmpi(obj.EventFileParseMethod,'vpixx') && (endsWith(lower(obj.EventFileName), '.vpixx') || endsWith(lower(obj.EventFileName), '.txt'))
                        [evID, evNames] = obj.readVpixxFile;
                        
                        % Add new parsing methods here.
                        %                elseif ...
                        %
                    else
                        continue
                    end
                catch
                    %%% Do nothing
                end
                if ~isempty(evID)
                    disp(['Event list updated from file "' obj.EventFileName '"'])
                    break
                end
            end
            % Throw warning if no event file was specified and no file was
            % successfully read:
            if isempty(p.Results.EventFileName) && isempty(evID)
                warning('Event File parsing aborted! Failed to parse "%s" file in "%s".\nDoes it exists in the Data Folder?',upper(obj.EventFileParseMethod), obj.RawFolder)
                return
            end
            assert(~isempty(evID),'Failed to parse "%s"! \nIs this a valid Event file?',obj.EventFileName)
            % Check if the eventID has the same length as the timestamps:
            assert(isequaln(length(obj.timestamps), length(evID)), 'Failed to update events from file "%s". There is a mismatch between the number of conditions and the number of triggers.', obj.EventFileName)
            % Save event ID and name lists:
            obj.eventID = evID;
            obj.eventNameList = evNames;
            obj.clearIgnoredEvents; % Reset lists of ignored Condition and Repetitions
            %
            status = true;
        end
        
        function removeCondition(obj, conditionName)
            % Add condition "conditionName" to the list of ignored conditions.
            % This will eliminate the whole condition, from the analysis
            % when the data will be split by events.
            if ~obj.validateCondition(conditionName);return;end
            
            obj.selectedEvents(strcmpi(conditionName,obj.eventNameList),:) = false;
            fprintf('Condition "%s" will be ignored!\n',conditionName)
            % Warn user that all conditions are ignored:
            if ~any(obj.selectedEvents)
                warning('All conditions were ignored! Data splitting by events will be impossible!')
            end
            % Update selectedEvents field in current "events.mat" file:
            obj.updateEventsFile('selectedEvents')
        end
        
        function removeRepetition(obj, conditionName, repetitionIndex)
            % Adds the repetition "repetitionIndex" to the list of ignored
            % repetitions for a given condition "conditionName".
            % This will eliminate a specific repetition or a set of repetitions
            % from the analysis when the data will be split by events.
            
            if ~obj.validateCondition(conditionName);return;end
            if ~obj.validateRepetition(conditionName, repetitionIndex);return;end
            
            idxCond = strcmpi(conditionName,obj.eventNameList);
            
            obj.selectedEvents(idxCond,repetitionIndex) = false;
            fprintf('Repetition "%d" from condition "%s" will be ignored!\n',repetitionIndex,conditionName);
            if all(~obj.selectedEvents(idxCond,:))
                warning('All repetitions from condition "%s" ignored. The whole condition will be ignored!\n',conditionName)
            end
            % Update selectedEvents field in current "events.mat" file:
            obj.updateEventsFile('selectedEvents')
        end
        
        function clearIgnoredEvents(obj)
            % Resets the lists of ignored conditions and repetitions to the default state (i.e. all trials included).
            if isempty(obj.state)
                % When there is no triggers detected. This should not be
                % reached.
                obj.selectedEvents = [];
            else
                % Set logical matrix with TRUEs to keep all repetitions.
                nEvents = arrayfun(@(x) sum(obj.eventID == x & obj.state),unique(obj.eventID));
                obj.selectedEvents = false(length(obj.eventNameList),max(nEvents));
                % Account for rare cases where the events do not have the
                % same number of reps:
                for ii = 1:length(nEvents)
                    obj.selectedEvents(ii,1:nEvents(ii)) = true;
                end
            end
            fprintf('Condition and Repetition lists successfully reset! All trials will be considered in the analysis.\n');
            obj.updateEventsFile('selectedEvents')
        end
                        
        function saveEvents(obj, saveFolder)
            % SAVEEVENTS creates the file "events.mat" in the
            % SaveFolder. This file is used by umIT to split the data into
            % trials.
            
            if nargin < 2
                % If no SaveFolder is provided, use the current value of
                % the SaveFolder propery:
                saveFolder = obj.SaveFolder;
            else
                % Update SaveFolder property:
                obj.SaveFolder = saveFolder;
            end
            if isempty(obj.timestamps)
                warning('Unable to create events.mat file. No triggers found!')
                return
            end
            % Trim all .dat files in the SaveFolder to exclude frames
            % outside trials:
            obj.trimDatFiles;                                    
            % Save Events data:
            RawFolder = obj.RawFolder; %#ok
            AnalogIN = obj.AnalogIN;%#ok
            eventID = obj.eventID; %#ok
            timestamps = obj.timestamps; %#ok
            state = obj.state; %#ok
            eventNameList = obj.eventNameList; %#ok
            baselinePeriod = obj.baselinePeriod; %#ok
            trigChanName = obj.trigChanName; %#ok
            selectedEvents = obj.selectedEvents; %#ok            
            % Save:
            save(fullfile(saveFolder, 'events.mat'),...
                'RawFolder',...
                'AnalogIN',...    
                'eventID',...                
                'state',...
                'timestamps',...
                'eventNameList',...
                'selectedEvents',...
                'baselinePeriod');
            disp(['Events MAT file saved in  ' saveFolder]);
        end
        
        function loadEvents(obj, Folder)
            % Load variables from events.mat file.
            if ~exist('Folder','var')
                if ~exist(fullfile(obj.SaveFolder,'events.mat'),'file')
                    % Consider the current folder the SaveFolder, if the input was not
                    % provided.
                    Folder = pwd;
                else
                    % Use the SaveFolder by default.
                    Folder = obj.SaveFolder;
                end
            end
            assert(any(exist(fullfile(Folder,'events.mat'),'file')), ['Failed to load event info! "events.mat" not found in ' Folder]);
            % Update SaveFolder:
            obj.SaveFolder = Folder;
            evInfo = load(fullfile(Folder,'events.mat'));
            fn = fieldnames(evInfo);
            % Get only existing fields:
            fn = intersect(fn,properties(obj),'stable');
            for ii = 1:length(fn)
                obj.(fn{ii}) = evInfo.(fn{ii});
            end            
            % Load Acquisition info:
            obj.setInfo            
            %
            if isempty(obj.selectedEvents)
                obj.clearIgnoredEvents;
            end
            if isempty(obj.baselinePeriod)
                obj.setBaselinePeriod;
            end
            fprintf('Events info loaded from folder %s\n', Folder);
        end
        
        function [frMat, conditionList, repetitionList] = getFrameMatrix(obj,varargin)
            % GETFRAMEMATRIX generates a matrix with dimensions Repetition x Frame indices
            % for each trial. The matrix output consists of the
            % frame indices split by trial (repetition). The matrix can be
            % used to split imaging data by trials and perform
            % event-triggered calculations.
            % This function outputs the matrix in 3 modes, depending on the inputs:
            %   1) No inputs (default): all conditions and repetitions
            %   2) conditionName only: all trials for the given condition
            %   3) conditionName + repetitionIndex: trials for the given
            %      repetition(s) of the selected condition.
            %
            % Inputs:
            %   obj: The object containing the data and methods.
            %   conditionName (char): Name of the condition to extract the trials.
            %   repetitionIndex (vector, int | optional): Repetition index(ices) of
            %       the condition. If not provided, all repetitions will be used.
            %   ignoreEvents (logical | optional): Boolean flag to indicate if some
            %       trials should be ignored based on the selectedEvents property.
            %       Default is false.
            %
            % Outputs:
            %   frMat (matrix): Matrix containing the frame indices of each trial.
            %       Frames that are out of bounds are marked as NaNs.
            %   conditionList (vecrot): List of conditions indices for each trial.
            %   repetitionList (vector): List of repetition indices for each trial.                       
                        
            % Input parsing and validation:
            p = inputParser();
            addRequired(p,'obj');
            addOptional(p,'conditionName','',@(x) ischar(x) | isStringScalar(x) )
            addOptional(p,'repetitionIndex',[],@(x) ( isnumeric(x) && all(x > 0) ) || isempty(x))
            addParameter(p,'ignoreEvents',false,@islogical)
            parse(p,obj,varargin{:});
            conditionName = convertStringsToChars(p.Results.conditionName);
            repetitionIndex = p.Results.repetitionIndex;
            b_ignoreEvents = p.Results.ignoreEvents;
            % Deny filtering repetition without condition name:
            if isempty(conditionName) && ~isempty(repetitionIndex)
                error('Repetition index cannot be set without the condition Name!')
            end
            % Check condition name:
            if ~isempty(conditionName)
                obj.validateCondition(conditionName)
            end
            if ~isempty(repetitionIndex)
                for ii = 1:length(repetitionIndex)
                    obj.validateRepetition(conditionName, repetitionIndex(ii));
                end
            end
            % Create frame index matrix:            
            frOn = ceil(obj.timestamps(obj.state)*obj.AcqInfo.FrameRateHz);
            frStart = frOn - round(obj.baselinePeriod*obj.AcqInfo.FrameRateHz) + 1;
            trialLen = [diff(frOn);max(diff(frOn))];
            frMat = nan(sum(obj.state),max(trialLen));
                        
            for ii = 1:length(frStart)                
                frVec = frStart(ii):frStart(ii)+trialLen(ii)-1;
                b_outbound_frames = frVec < 1 | frVec > obj.AcqInfo.Length;
                frVec(b_outbound_frames) = nan;                
                frMat(ii,1:length(frVec)) = frVec;
            end
            % Create output lists (condition and repetition)
            conditionList = obj.eventID(obj.state);
            repetitionList = zeros(size(conditionList));
            skipEvIdx = false(size(conditionList));
            for ii = 1:length(obj.eventNameList)
                idx_cond = obj.eventID(obj.state) == ii;                
                repetitionList(idx_cond) = 1:sum(idx_cond);
                skipEvIdx(idx_cond) = obj.selectedEvents(ii,:);
            end
            if ~b_ignoreEvents
                % Force selection of all trials:
                skipEvIdx = true(size(skipEvIdx));
            end
            % Filter Frame Index matrix, if the user defined the conditions
            % and/repetitions:
            % Condition:
            condIdx = true(size(frMat,1),1);  
            repIdx = condIdx;
            if ~isempty(conditionName)
                condIdx = ( obj.eventID(obj.state) == find(strcmp(conditionName,obj.eventNameList)) );                
            end
            % Repetitions:
            if ~isempty(repetitionIndex)
                repIdx = zeros(size(condIdx));
                repIdx(condIdx) = find(condIdx) - find(condIdx,1,'first') + 1;
                repIdx = ismember(repIdx,repetitionIndex);               
            end
            % Update output matrix and lists:
            frMat = frMat(condIdx & repIdx & skipEvIdx,:);
            conditionList = conditionList(condIdx & repIdx & skipEvIdx);
            repetitionList = repetitionList(condIdx & repIdx & skipEvIdx);
        end
        
        function [dataByEv, conditionList, repetitionList] = splitDataByEvents(obj,data,varargin)
            % SPLITDATABYEVENT uses the function getFrameMatrix to split 3D
            % image time series by trials. 
            % Inputs:
            %
            %    data (3D num array): Image time series with dimensions Y, X, T.
            %    varargin: Optional parameters as name-value pairs!:
            %       'conditionName' (char or string): Name of the condition to filter trials.
            %       'repetitionIndex' (numeric array): Indices of repetitions to include.
            %       'ignoreEvents' (logical): Boolean flag to indicate if some
            %           trials should be ignored based on the selectedEvents property.
            %           (default: false).
            %       'cropTrials' (logical): Flag to crop trials to avoid frames full of NaNs (default: false).
            %
            % Output:
            %    dataByEv (4D num array): Image time series by events with
            %       dimensions E, Y, X, T.
            %    conditionList (vector): List of condition indices for each trial.
            %    repetitionList (vector): List of repetition indices for each trial.           
           
           % Input parsing and validation:
           p = inputParser();
           addRequired(p,'obj');
           addRequired(p,'data');           
           addParameter(p,'conditionName','',@(x) ischar(x) | isStringScalar(x) )
           addParameter(p,'repetitionIndex',[],@(x) ( isnumeric(x) && all(x > 0) ) || isempty(x))
           addParameter(p,'ignoreEvents',false,@islogical)
           addParameter(p,'cropTrials',false,@islogical);
          
           parse(p,obj,data,varargin{:});
           
           % Check if the input data matches the dimensions stored in
           % AcqInfo:
           assert(isequaln(size(data),[obj.AcqInfo.Height, obj.AcqInfo.Width, obj.AcqInfo.Length]),...
               'Failed to split data by events! The dimensions of the input data do not match the ones in the AcqInfo structure!');
           % get frame matrix
           [frMat,conditionList, repetitionList] = obj.getFrameMatrix(p.Results.conditionName,...
               p.Results.repetitionIndex,'ignoreEvents',p.Results.ignoreEvents);
                      
           if p.Results.cropTrials
               % Crop trials to avoid creating frames full of nans due to
               % differences in trial lengths:
               frMat(:,any(isnan(frMat),1)) = [];
           end
           % Split the data:   
           
           dataByEv = nan(size(frMat,1),size(data,1),size(data,2),size(frMat,2),'single');
           b_validFrames = ~isnan(frMat);
           for ii = 1:size(frMat,1)
               dataByEv(ii,:,:,b_validFrames(ii,:)) = data(:,:,frMat(ii,b_validFrames(ii,:)));
           end                     
        end
                
    end
    
    methods (Access = private)
        
        function setInfo(obj)
            % SETINFO reads the content of the "AcqInfoStream" structure in the
            % SaveFolder and updates the fields for retrocompatibility.
            % In addition, it uses the information to update the properties:
            % "sr" and "trigChanName" (for trigger detection).
            
            % Check if AcqInfos file exists:
            %             assert(any(exist(fullfile(obj.RawFolder, 'info.txt'),'file')),...
            %                 ['Unable to read experiment metadata. The file "info.txt" is missing in folder "'...
            %                 obj.RawFolder '". Execute Images Classification and try again.']);
            % Load existing info:
            try
                a = load(fullfile(obj.SaveFolder, 'AcqInfos.mat'));
                obj.AcqInfo = a.AcqInfoStream;
            catch
                obj.AcqInfo = ReadInfoFile(obj.RawFolder);
            end
            
            % Get AnalogIN channel list:
            fn = fieldnames(obj.AcqInfo);
            idxChan = startsWith(fn,'AICh', 'IgnoreCase',true);
            if ~any(idxChan)
                % For retrocompatibility with older versions of the "info.txt"
                %   file where the names of AIchannels are not set. Here, we
                %   infer the names of the channels based on the total number of channels:
                
                % Initiate list with the names of the CameraTrigger and internal
                % channels, then,
                obj.AIChanList = cell(obj.AcqInfo.AINChannels,1);
                switch obj.AcqInfo.AINChannels
                    case 1
                        % Cage system:
                        obj.AIChanList(1) = {'CameraTrig'};
                        idx = 2;
                    case {2,6,10}
                        % Cage (n=2) or OiS200 (n=6,10) system. Camera and single internal trigger:
                        obj.AIChanList(1:2) = {'CameraTrig', 'StimAna1'};
                        idx = 3;
                    case {3,7,11}
                        % Cage (n=3) or OiS200 (n=7,11) system. Camera and double internal triggers:
                        obj.AIChanList(1:3) = {'CameraTrig', 'StimAna1', 'StimAna2'};
                        idx = 4;
                    otherwise
                        error('Failed to infer channel names from "info.txt" file!')
                end
                for ii = 0:obj.AcqInfo.AINChannels-idx
                    % Fill the rest of the channel names with the analog IN
                    obj.AIChanList{ii+idx} = ['AI', num2str(ii+1)];
                end
                % Add fields to AcqInfo property:
                for ii = 1:length(obj.AIChanList)
                    obj.AcqInfo.(['AICh' num2str(ii)]) = obj.AIChanList{ii};
                end
            else
                obj.AIChanList = cellfun(@(x) obj.AcqInfo.(x),fn(idxChan),'UniformOutput',false);
            end
            
            % Validate if the list of channel names match the number of
            % channels:
            assert(isequaln(length(obj.AIChanList),obj.AcqInfo.AINChannels),...
                'Mismatch found between list of channel names and total number of channels! Check "info.txt" file!')
            % Validate if all AnalogIN names exist in the dictionary. (This
            %   will keep devs up-to-date on changes in the "info.txt" file)
            assert(all(ismember(lower(obj.AIChanList), lower(obj.dictAIChan))),'Unexpected AnalogIN channel name found in "info.txt" file!');
            % Update Analog input sample rate:
            obj.sr = obj.AcqInfo.AISampleRate;
            
            % Update trigger names:
            if any(startsWith(fn,'event','IgnoreCase',true))
                % For digital stimulation:
                obj.b_isDigital = true;
                obj.trigChanName = 'StimDig';
                return
            end
            % Update trigger names for Analog Stims:
            b_hasStim1 = any(cellfun(@any,regexpi(fn,'stimulation1_')));
            b_hasStim2 = any(cellfun(@any,regexpi(fn,'stimulation2_')));
            if ~any([b_hasStim1, b_hasStim2])
                return
            end
            names = {'StimAna1','StimAna2'};
            obj.trigChanName = names([b_hasStim1, b_hasStim2]);
            % Use the pulse information from analog stim to update the
            % minimal interStim interval for detection of bursts stim.
            % blocks. We set the minimal interstim as the largest pulse
            % interstim with an extra 15%.
            idxBurst = contains(fn,'burst_delay','IgnoreCase',true);
            idxPeriod = contains(fn,'_period','IgnoreCase',true);
            idxFreq = contains(fn,'_frequency','IgnoreCase',true);
            if any(idxBurst) && obj.AcqInfo.(fn{find(idxBurst,1,'first')}) > 0
                % Use burst delay
                burst_delay = obj.AcqInfo.(fn{find(idxBurst,1,'first')});
                stim_period = obj.AcqInfo.(fn{find(idxPeriod,1,'first')});
                obj.minInterStim = 1.15*(burst_delay + stim_period)/1000; % Add 15% to the value of the burst delay
            elseif any(idxPeriod)
                % Use the pulse period
                obj.minInterStim = 1.15*(obj.AcqInfo.(fn{find(idxPeriod,1,'first')}))/1000;% Add 15% to the value of the pulse period
            else
                % Calculate the pulse period from frequency (older
                % "info.txt" versions)
                obj.minInterStim = 1.15*(1/obj.AcqInfo.(fn{find(idxFreq,1,'first')}));% Add 15% to the value of the pulse period
            end
            
        end
        
        function [timestamps, state] = detectTrig(obj, data)
            % DETECTTRIG detects the triggers from a given signal and
            %   outputs the timestamps and state. THis function is called by
            %   the method "getTriggers".
            % Input:
            %    data(1xN num. vector): vector containing the triggers.
            % Outputs:
            %    timestamps (num vect.): time delay (in seconds) of triggers detected.
            %    state (num vect.): state of the trigger: 1 = rising; 0 = falling.
            
            timestamps = single.empty();
            state = uint8.empty();
            % Check if "data" is a vector;
            validateattributes(data,{'single','double'},{'vector'});
            %
            if size(data,1) > size(data,2)
                data = data';
            end
            % Check for biphasic signal:
            % Here, a biphasic signal is considered to have a positive
            % followed
            % a negative pulse.
            if ~isequaln(data,abs(data))
                disp('Biphasic signal detected.')
                data = abs(data);
            end
            %
            if strcmpi(obj.trigThr, 'auto')
                trigAmp = (.8*(max(data(:)) - min(data(:))));
                % Control for the minimal amplitude for trigger detection
                if trigAmp < obj.minTrigAmp
                    warning('Operation Aborted! The trigger amplitude is too low for automatic detection! Manually set a threshold and try again.');
                    return
                end
                % Update trigger threshold value:
                obj.trigThr = trigAmp + min(data(:));
            end
            
            % Find samples that cross the threshold (rising and falling):
            tmRise = find(data < obj.trigThr & [data(2:end) nan] > obj.trigThr);
            tmFall = find(data > obj.trigThr & [data(2:end) nan] < obj.trigThr);
            if isempty(tmRise)
                return
            elseif numel(tmRise) ~= numel(tmFall)
                % Need to decide what to do in this case. For now, throw a
                % warning.
                warning('Number of rising and falling edges are not equal!')
                return
            end
            timestamps = single([tmRise tmFall]./obj.sr);
            state = [ones(1,numel(tmRise), 'uint8') zeros(1,numel(tmFall), 'uint8')];
            % Sort arrays by time and flip:
            [timestamps,idx] = sort(timestamps);
            timestamps = timestamps';
            state = state(idx)';
            % For Toggle type triggers:
            if strcmpi(obj.trigType, 'edgetoggle')
                % Use 2nd signal onset as the trial "OFF" state:
                timestamps = timestamps(state==1);
                % Overwite state:
                state = ones(sum(state),1,'uint8');
                state(2:2:end) = 0;
            end
            
            % Deal with bursts stimuli:
            StimLim = find(diff(timestamps(state ==1)) >= obj.minInterStim); %
            NbStim = length(StimLim)+1;
            if NbStim < sum(state) && ~obj.b_isDigital
                disp('Burst stim detected.')
                BurstOff = [StimLim; length(tmFall)];
                BurstOn = [1; StimLim+1];
                % Update timestamps and state:
                tmRise = tmRise(BurstOn);
                tmFall = tmFall(BurstOff);
                % Recalculate the timestamps and state:
                timestamps = single([tmRise tmFall]./obj.sr);
                state = [ones(1,numel(tmRise), 'uint8') zeros(1,numel(tmFall), 'uint8')];
                % Sort arrays by time and flip:
                [timestamps,idx] = sort(timestamps);
                timestamps = timestamps';
                state = state(idx)';
            end
            % Update timestamps and states for digital stim. Digital stim
            %   will only have a toggle marking the stim onset and the
            %   duration (in seconds) is recorded in the "info.txt" file.
            if obj.b_isDigital
                fn = regexp(fieldnames(obj.AcqInfo),'Stim\d+','match','once');
                fn(cellfun(@isempty,fn)) = [];
                stimInfo = cellfun(@(x) obj.AcqInfo.(x), fn);
                durationMap = containers.Map([stimInfo.ID],[stimInfo.Duration]);
                durationOrder = arrayfun(@(x) durationMap(x), obj.AcqInfo.Events_Order);
                timestamps = reshape([timestamps(state == 1)'; timestamps(state ==1)' + durationOrder],numel(state),[]); % Create timestamps to mark the end of the stim (trigger + duration_sec);
            end
        end
        %%%%% Event File parsers %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function [eventID, eventNameList] = readCSVfile(obj, colName)
            % READCSVFILE reads a .CSV file. If no column name is provided,
            % it reads the content of the first column and considers it
            % without header. If one column name is provided, it reads the
            % rows of the given column. If 2 or more column names are
            % provided, the values of the column names are concatenated
            % with a hiphen ("-").
            % Input:
            %    colName(optional, char|cell): column name(s) to be read
            %    from the CSV file.
            % Outputs:
            %    eventID (num vect.): list of indices of the events listed
            %    in "eventNameList".
            %    eventNameList (cell): list of event names in alphabetical
            %    order.
            % Set CSV reading rules:
            opts = detectImportOptions(obj.EventFileName);
            if ~exist('colName','var') || isempty(colName)
                colName = {''};
            elseif ischar(colName)
                colName = {colName};
            end
            
            if ~isempty([colName{:}])
                opts.SelectedVariableNames = colName; % Select the input columns only.
            else
                colName = {''}; % USe columns without headers.
                opts.DataLines(1) = 1;
            end
            %             opts.DataLines = 2; %Start reading at 2nd row.
            opts.VariableTypes = repmat({'char'},size(opts.VariableTypes)); % Force data to characters.
            opts.MissingRule = 'omitrow'; % Remove rows with missing values.
            opts.ExtraColumnsRule = 'ignore'; % Ignore empty columns.
            % Read .CSV file:
            out = table2cell(readtable(obj.EventFileName,opts));
            % Merge multiple columns into a single one:
            nameList = cell(size(out,1),1);
            for ii = 1:size(out,1)
                if ~isempty([colName{:}])
                    nameList{ii} = strjoin(reshape(vertcat(colName,out(ii,:)),1,[]),'-');
                else
                    nameList{ii} = strjoin(out(ii,:),'-');
                end
            end
            eventNameList = unique(nameList,'stable');
            nameMap = containers.Map(eventNameList,1:length(eventNameList));
            eventID = zeros(length(nameList),1);
            for ii = 1:length(nameList)
                % Generate event ID from event name index.
                eventID(ii) = nameMap(nameList{ii});
            end
            % Duplicate the eventID to account for low state (considering
            % that there is no overlap between conditions).
            eventID = repelem(eventID,2);
        end
        
        function [eventID, eventNameList] = readVpixxFile(obj)
            % READVPIXXFILE extracts the condition ID, name and timestamps (if applicable)
            %   from the RAW DATA section of a .txt or .vpixx file.
            % Outputs:
            %    eventID (num vect.): list of indices of the events listed
            %    in "eventNameList".
            %    eventNameList (cell): list of event names in alphabetical
            %    order.
            
            % Extract only the part of the text containing the real sequence of
            %   conditions (RAW DATA section):
            filetext = fileread(obj.EventFileName);
            [~,idx_start] = regexp(filetext, 'RAW DATA');
            idx_stop = regexp(filetext, 'SORTED');
            filetext = strip(filetext(idx_start+1:idx_stop-1));
            if isempty(filetext)
                return
            end
            tab = strsplit(filetext, '\n')';
            % Get stimulus ID and order. Ignore Event and Time columns for now!
            out = {};
            myCols = [2 3]; % Keep just Condition and Stimulus.
            for i = 2:length(tab)
                str = strsplit(tab{i},'\t');
                if isempty(str{1})
                    % Skip Event rows.
                    continue
                end
                out = [out;str(myCols)];
            end
            out(:,1) = cellfun(@str2double, out(:,1), 'UniformOutput',false);
            eventID = [out{:,1}]';
            IDs = unique(eventID);
            eventNameList = cell(length(IDs),1);
            for ii = 1:length(IDs)
                idx = find(eventID == IDs(ii),1,'first');
                eventNameList(ii) = out(idx,2);
            end
            % Duplicate the eventID to account for low state (considering
            % that there is no overlap between conditions).
            eventID = repelem(eventID,2);
        end
        %%%% Validators %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function bOk = validateCondition(obj, conditionName)
            % Validates if the input condition exists in the
            % "eventNameList" and if it is not ignored. ATTENTION: !Case Insensitive!
            validateattributes(conditionName,{'char'},{'scalartext'});
            % Check if the selectedEvents propery was already set:
            assert(~isempty(obj.selectedEvents),'List of selected Events not set yet! Execute getTriggers and try again!');
            
            bOk = false;
            idxCond = strcmpi(conditionName, obj.eventNameList);
            % Check if it exists:
            if ~any(idxCond)
                error('The condition with name "%s" does not exist in the "eventNameList".', conditionName);
            end
            % Check if it was not blacklisted:
            if all(~obj.selectedEvents(idxCond,:))
                warning('The condition with name "%s" is already listed as ignored!',conditionName)
                return
            end
            bOk = true;
        end
        
        function bOk = validateRepetition(obj, conditionName, repetitionIndex)
            % Validates if the input repetition exists and if it it is not ignored.
            validateattributes(repetitionIndex,{'single','double'},{'scalar'});
            % Validate the condition name first:
            obj.validateCondition(conditionName);
            % Check if the repetitionIndex provided is valid:
            assert(repetitionIndex <=size(obj.selectedEvents,2),'The repetition index provided is out of bounds!')
            bOk = false;
            
            if ~obj.selectedEvents(strcmpi(conditionName,obj.eventNameList),repetitionIndex)
                warning('The repetition "%d" from the condition "%s" is already listed as ignored!',repetitionIndex,conditionName);
                return
            end
            bOk = true;
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function delete(obj)
            % Class destructor. Re-enables original warnings.
            warning(obj.warnOrigState)
        end
        
        function updateEventsFile(obj,fieldname)
            % Updates a given field in an existing "events.mat" file.
            
            if ~isfile(fullfile(obj.SaveFolder,'events.mat'))
                return
            end
            evFile = matfile(fullfile(obj.SaveFolder,'events.mat'),'Writable',true);
            evFile.(fieldname)= obj.(fieldname);
        end
        
        function trimDatFiles(obj)
           % TRIMDATFILES removes all frames that are outside the range of the trials. 
           % This is a permanent operation and it should be executed only
           % once in a given dataset (SaveFolder). This applies only to
           % .dat files and not the data saved in .mat files.
           
           % Return if the baselinePeriod property was not changed. No need
           % to crop the data.  
           if isfile(fullfile(obj.SaveFolder,'events.mat'))
               evFile = matfile(fullfile(obj.SaveFolder,'events.mat'));
               if evFile.baselinePeriod == obj.baselinePeriod
                   return
               end
           end
           % Raise error if the data was already cropped:
           errMsg = ['Data trimming aborted! The data in folder "%s" was already cropped!\n',...
               'Please, re-import the data to apply the intended changes.'];
           bWasTrimmed = false; 
           if isfield(obj.AcqInfo,'bDataTrimmed')
               bWasTrimmed = obj.AcqInfo.bDataTrimmed;
           end
           assert(~bWasTrimmed,errMsg,obj.SaveFolder)
           % Get the frames out of bounds:
           frMat = obj.getFrameMatrix;
           frRange = [min(frMat,[],'all','omitnan'),max(frMat,[],'all','omitnan')];
           if frRange(1) == 1 && frRange(2) == obj.AcqInfo.Length
               disp('Data length is already set for trials.')
               return
           end
           fprintf('All .dat files in the "%s" will be trimmed to fit trial sizes.\n',obj.SaveFolder)
           % Crop all .dat files:
           fList = dir(fullfile(obj.SaveFolder,'*.dat'));
           for ii = 1:length(fList)
               dat = loadDat(fullfile(obj.SaveFolder,fList(ii).name));
               dat = dat(:,:,frRange(1):frRange(2));
               saveDat(fullfile(obj.SaveFolder,fList(ii).name),dat);               
           end
           clear dat
           fprintf('Finished trimming .dat files.\n');
           
           % Update info in this object:
           obj.AcqInfo.Length = diff(frRange)+1;
           % Add flag:
           obj.AcqInfo.bDataTrimmed = true;
           % Overwrite "AcqInfos.mat" file:
           AcqInfoStream = obj.AcqInfo;
           save(fullfile(obj.SaveFolder,'AcqInfos.mat'),'AcqInfoStream');
           fprintf('AcqInfos.mat file updated.\n')
           clear AcqInfoStream
           % Update timestamps:
           time_shift = frRange(1)/obj.AcqInfo.FrameRateHz;
           obj.timestamps = obj.timestamps - time_shift;
           % Crop AnalogIN (internal only. ai_xxxxx.bin files are not
           % changed!)
           aiFrame = round(time_shift*obj.sr);
           obj.AnalogIN(1:aiFrame-1,:) = [];
           fprintf('AnalogIN updated.\n')           
        end        
        
    end
end


