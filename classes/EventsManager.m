classdef EventsManager < handle
    % EVENTSMANAGER. A class to manage triggers and meta data (event IDs and names)
    %   in order to create an "events.mat" file to be used by umIT. This
    %   class deals exclusively with data generated by LabeoTech imaging
    %   systems (e.g. OiS200).
    properties
        trigThr = 'auto'; % Trigger detection Threshold in volts (Default = 'auto'). The 'auto' means that the threshold will be at 70% of the signal amplitude.
        trigType char = 'EdgeSet' % Trigger type.
        trigChanName = {''}; % Name of AI channel(s) containing the triggers.
        minInterStim single {mustBeNonnegative} = 2 % Minimal inter stim time (in seconds). This param. is used to identify Bursts in analogIN. !This value should be higher than the inter-burst value to work!
        RawFolder char % Folder containing the ai_xxxx.bin and (optionally) the Event list file.
    end
    properties (SetAccess = private)
        dictAIChan cell = {'CameraTrig', 'CameraTrig2', 'InputTrigger',...
            'StimAna1','StimAna2', 'StimDig', 'Optogen', 'Unused',...
            'AI1', 'AI2','AI3','AI4','AI5','AI6','AI7','AI8'}; %  List of all available channels from Imaging system:
        AIChanList cell % List of Analog IN channels obtained from "AcqInfo".
        SaveFolder char % Folder containing the "AcqInfos.mat" file. Default folder to save/load the "events.mat" file.
        AcqInfo struct % Content of the info.txt file as a structure.
        AnalogIN single % Array of analog input data.
        sr single {mustBePositive} = 10000; % Sample rate of analog input channels in Hz.
        timestamps single {mustBeNonnegative} % Time stamps in seconds of triggers.
        state logical {mustBeNonnegative} % State of triggers (1= ON, 0 = OFF)
        eventID uint16 {mustBePositive} % Index of each condition (1, 2, 3 ...)
        repetitionID uint16 {mustBePositive} % Index of repetition from each condition.
        eventNameList cell % Name of each condition.
        baselinePeriod single{mustBePositive} % Trial baseline duration (in seconds) for splitting data by trials.
        selectedEvents logical % Matrix (Event by Repetition) of repetitions to be used when splitting the data by trials (TRUE = keep;FALSE = ignore).
        b_isDigital logical = false; % TRUE for digital stimulation using OiS200 as master.
        minTrigAmp single {mustBePositive} = .15; % Minimal signal amplitude (in Volts). Used when the trigger threshold is "auto". Ignored otherwise.
        EventFileName char % Name of the event file containing events information (.csv, .txt, .vpixx ...).
    end
    properties (Access = private)
        warnOrigState % original state of Matlab's warnings. This will be restored at this class destruction.
        ParseMethods = {'none','csv','vpixx'}; % List of valid parse methods.
        privateEventFileParseMethod;
        b_LP_applied = false % Boolean to indicate if a low-pass filtering was applied to the AnalogIN data.
    end
    properties (Dependent)
        EventFileParseMethod char % Name of the method to read the Event File. {'CSV','vpixx'};
    end
    
    methods
        function obj = EventsManager(varargin)
            % This is the constructor method.
            % It instantiates the object and sets the values for the
            % DataFolder and EventFileName properties.
            % It reads the analog IN channels and the info.txt as well.
            % Inputs:
            %   SaveFolder (char): path to the folder containing the
            %       AcqInfos.mat file. This will be the folder where the
            %       "events.mat" file will be saved or loaded from.
            %   RawFolder (char): path to the folder containing the
            %       ai_xxxx.bin data and "info.txt" file. If not provided,
            %       load an "events.mat" file or manually set the
            %       RawFolder later.
            %   ParseMethod (optional, char): Name of the parsing method to
            %   apply to the event file containing the list of event
            %   IDs:{'none'(default),'csv','vpixx'}.
            
            % Input validation:
            p = inputParser;
            addOptional(p,'SaveFolder',pwd,@isfolder)
            addOptional(p,'RawFolder','',@ischar)
            addOptional(p, 'ParseMethod','csv',@(x) ismember(lower(x),obj.ParseMethods));
            parse(p,varargin{:});
            
            % Disable backtrace warnings:
            obj.warnOrigState = warning;
            warning('off', 'backtrace');
            
            % Set main properties:
            obj.SaveFolder = p.Results.SaveFolder;
            obj.RawFolder = p.Results.RawFolder;
            obj.EventFileParseMethod = lower(p.Results.ParseMethod);
            % Set properties based on the AcqInfo.mat file:
            try
                obj.setInfo;
            catch
                warning('The folder "%s" does not contain the "AcqInfos.mat" file. Set a valid DataFolder or load an "events.mat" file.',obj.SaveFolder);
                return
            end
            
            % Load "events.mat", if it exists in the save
            % folder:
            if isfile(fullfile(obj.SaveFolder,'events.mat'));
                obj.loadEvents;
                return
            end
            % Read AnalogIN if the RawFolder was set:
            if ~isempty(obj.RawFolder)
                % Set AnalogIN property:
                obj.setAnalogIN;
                % Detect internally-generated triggers:
                if ~isempty([obj.trigChanName{:}])
                    obj.getTriggers;
                end
            end
            % Force EventFileParseMethod to "none" if the stimulus is
            % digital. In this case, the event info should already be
            % stated in the "info.txt" file (to be confirmed)
            if obj.b_isDigital && ~strcmpi(obj.EventFileParseMethod, 'none')
                warning('Event file parsing method set to "none" because the stimulus is digital.')
                obj.EventFileParseMethod = 'none';
            end
        end
        
        function set.EventFileParseMethod(obj, parseMethod)
            % Set method for event file parse method. Just checks if the
            % input is valid. Valid parsing methods are stored in the
            % property "ParseMethods".
            
            parseMethod = lower(convertStringsToChars(parseMethod));
            validateattributes(parseMethod,{'char'},{'scalartext'}, 'set.EventFileParseMethod');
            msg = [sprintf('Invalid parse method "%s". It must be one of the following:',parseMethod),...
                sprintf('\n%s',obj.ParseMethods{:})];
            assert(ismember(parseMethod,obj.ParseMethods),msg);
            obj.privateEventFileParseMethod = parseMethod;
        end
        
        function set.trigChanName(obj, trigName)
            % Set method for trigger channel name.
            % Forces the property to a cell.
            if ischar(trigName)
                obj.trigChanName = {trigName};
            elseif iscell(trigName)
                obj.trigChanName = trigName;
            else
                error(['Format ' class(trigName) ' not supported! It must be char or cell array of chars.'])
            end
        end
        
        function set.trigType(obj, trigType)
            assert(ismember(lower(trigType), {'edgeset','edgetoggle'}),'Invalid trigger type! It must be either "EdgeSet" or "EdgeToggle".')
            obj.trigType = lower(trigType);
        end
        
        function setBaselinePeriod(obj,baselinePeriod)
            % Sets the baseline period (pre-event onset time) property with
            % for trial splitting. The user can manually set the baseline period.
            % If not, this period will correspond to 20% of the trial length.
            %
            % Parameters:
            %   baseline_period (scalar): The time period before the event onset.
            %
            % Example:
            %   obj.setBaselinePeriod(); % Uses default values
            %   obj.setBaselinePeriod(2) % Sets the preEventTime to 2s and
            %       use the remainder of the total trial length as the
            %       postEvent time.
            
            % Check for triggers:
            assert(~isempty(obj.state), 'Failed to set trial interval! No triggers detected yet!')
            
            % Validate baseline period:
            tm_on = obj.timestamps(obj.state);
            trial_length = diff(tm_on);
            if ~exist('baselinePeriod','var')
                % Set baseline duration as 20% of the minimal total trial
                % length:
                baselinePeriod = 0.2*(min(trial_length));
            else
                % Check if the user-defined baseline period is valid
                % following the criteria below:
                %   1) Is not larger than the trial length minus a frame.
                %   2) Is not smaller than a single frame.
                % This is to avoid frames falling in two consecutive trials
                % (overlapping trials).
                max_baseline_allowed = min(diff(tm_on) - 1/obj.AcqInfo.FrameRateHz);
                % Criterion 1):
                assert(baselinePeriod < max_baseline_allowed,...
                    'Baseline time period is too long! It must be shorter than %0.2f seconds!',max_baseline_allowed);
                % Criterion 2):
                assert(baselinePeriod >= 1/obj.AcqInfo.FrameRateHz,...
                    'Baseline time period is too short! It must be larger than %0.2f seconds!',1/obj.AcqInfo.FrameRateHz);
            end
            % Update baseline period value
            obj.baselinePeriod = baselinePeriod;
            fprintf('Baseline period set to %0.2f seconds.\n',obj.baselinePeriod)
        end
        
        function setAnalogIN(obj)
            % SETANALOGIN reads the ai_xxxx.bin files and saves it in "AnalogIN" property.
            % List of analog files containing raw data:
            
            aiFilesList = dir(fullfile(obj.RawFolder,'ai_*.bin'));
            if isempty(aiFilesList)
                warning(['Analog Input files (ai_xxxx.bin) not found in "' obj.RawFolder '"'])
                return
            end
            % Check if the AcqInfos structure exists:
            if isempty(obj.AcqInfo)
                obj.setInfo;
            end
            disp('Reading analog inputs...')
            % Opening of the files:
            obj.AnalogIN = [];
            for ind = 1:size(aiFilesList,1)
                data = memmapfile(fullfile(obj.RawFolder,aiFilesList(ind).name),...
                    'Offset', 5*4, 'Format', 'double', 'repeat', inf);
                tmp = data.Data;
                tmp = reshape(tmp, 1e4, obj.AcqInfo.AINChannels, []);
                tmp = permute(tmp,[1 3 2]);
                tmp = reshape(tmp,[],obj.AcqInfo.AINChannels);
                obj.AnalogIN = [obj.AnalogIN; tmp];
            end
            % Crop to first and last camera triggers:
            camT = diff(obj.AnalogIN(:,1) > 2.5); camT = [camT;NaN];
            camTOn = find(camT == 1,1,'first');
            camTOff = find(camT == -1,1,'last');
            obj.AnalogIN = obj.AnalogIN(camTOn:camTOff,:);
            disp('Done')
        end
        
        function out = get.EventFileParseMethod(obj)
            out = obj.privateEventFileParseMethod;
        end
        
        function out = get.repetitionID(obj)
            % Generates the repetition index of each condition.
            out = [];
            if isempty(obj.eventID);return;end
            % Create list
            IDlist = obj.eventID(obj.state);
            out = zeros(size(IDlist), class(IDlist));
            for ii = 1:length(obj.eventNameList)
                idx = IDlist == ii;
                out(idx) = 1:sum(idx);
            end
            out = repelem(out,2,1);
        end
        
        function getTriggers(obj, varargin)
            % GETTRIGGERS detects the triggers from one or more analog IN channels
            %   with names stored in the "trigChanName" property.
            % It records the timestamps and state of each event.
            % Input:
            %   b_verbose(bool, default = FALSE): If TRUE, displays some basic stats on
            %   trigger detection on the command window.
            %
            p = inputParser;
            addRequired(p,'obj');
            addOptional(p,'ChannelName','',@(x) ischar(x) || iscellstr(x) || isstring(x));
            addOptional(p,'b_verbose',true,@islogical)
            addParameter(p,'FilterFreq',0,@(x) isscalar(x) & x>=0)
            parse(p,obj,varargin{:})
            chanName = convertStringsToChars(p.Results.ChannelName);
            b_verbose = p.Results.b_verbose;
            FilterFreq = p.Results.FilterFreq;
            
            if ~isempty(chanName)
                obj.trigChanName = chanName;
            elseif isempty(chanName) && isempty([obj.trigChanName{:}])
                warning('Trigger channel name not set! Trigger detection aborted.')
                return
            end
            if isempty(obj.AnalogIN)
                % Read AnalogIN data:
                obj.setAnalogIN;
            end
            if ( FilterFreq > 0 && FilterFreq < obj.sr/2 )
                % Apply low-pass filter to the data at selected cut-off
                % frequency:
                f = fdesign.lowpass('N,F3dB', 4, FilterFreq, obj.sr); %Fluo lower Freq
                lpass = design(f,'butter');
                obj.b_LP_applied = true;
            end
            
            if obj.b_LP_applied
                % Reset AnalogIN data to original, if a filtering was
                % already applied.
                obj.setAnalogIN;
                obj.b_LP_applied = false;
            end
            % Reset event info:
            obj.timestamps = [];
            obj.state = [];
            obj.eventID = [];
            obj.eventNameList = {};
            
            % Get triggers:
            for ii = 1:length(obj.trigChanName)
                idxCh = strcmpi(obj.trigChanName{ii},obj.AIChanList);
                if ~any(idxCh)
                    warning(['Channel ' obj.trigChanName{ii} ' not found!'])
                    continue
                end
                if FilterFreq
                    % Apply low-pass filter to the data at selected cut-off
                    % frequency:
                    obj.AnalogIN(:,idxCh) = single(filtfilt(lpass.sosMatrix, lpass.ScaleValues, double(obj.AnalogIN(:,idxCh))')');
                end
                [tmstmp,chanState] = obj.detectTrig(obj.AnalogIN(:,idxCh));
                % Control for failed detections:
                if isempty(tmstmp)
                    warning(['Failed to detect triggers in channel "' obj.trigChanName{ii} '".'])
                    continue
                else
                    disp(['Triggers detected in channel "' obj.trigChanName{ii} '".']);
                end
                
                obj.timestamps = [obj.timestamps;tmstmp];
                obj.state = [obj.state;chanState];
                % Create dummy event ID:
                obj.eventID = [obj.eventID; ones(length(tmstmp),1).*ii];
                
                % Special Case: For internal analog triggers, use the
                % "Name" field of the channel instead of the channel ID.
                num = erase(obj.trigChanName{ii}, 'StimAna');
                if startsWith(obj.trigChanName{ii}, 'StimAna') && isfield(obj.AcqInfo, ['Stimulation' num '_Name'])
                    obj.eventNameList{ii} = obj.AcqInfo.(['Stimulation' num '_Name']);
                else
                    obj.eventNameList = [obj.eventNameList, obj.trigChanName(ii)];
                end
            end
            if isempty(obj.timestamps)
                return
            end
            [obj.timestamps,indx] = sort(obj.timestamps);
            obj.state = obj.state(indx);
            obj.eventID = obj.eventID(indx);
            
            % For digital stimulation, update event ID and event Name lists:
            if obj.b_isDigital
                % Overwrite dummy eventIDs with real ones from the info.txt.
                obj.eventID = ones(size(obj.state));
                obj.eventID(obj.state == 1) = obj.AcqInfo.Events_Order;
                obj.eventID(obj.state == 0) = obj.AcqInfo.Events_Order;
                fn = regexp(fieldnames(obj.AcqInfo),'Stim\d+','match','once');
                fn(cellfun(@isempty,fn)) = [];
                IDs = cellfun(@(x) obj.AcqInfo.(x).ID,fn);
                Names = cellfun(@(x) obj.AcqInfo.(x).Name,fn, 'UniformOutput',false);
                [~,idx] = sort(IDs);
                obj.eventNameList = Names(idx);
                disp('Trigger timestamps generated.');
            end
            % Validate triggers:
            % Checks for equality of lengths of eventID and timestamps
            errID = 'Umitoolbox:EventsManager:IncompatibleArraySizes';
            msg = 'IncompatibleArraySizes: eventID and timestamps must have the same length.';
            assert(isequal(length(obj.eventID), length(obj.state), length(obj.timestamps)), errID, msg)
            % Check if the number of elements in eventNameList:
            if ~isempty(obj.eventNameList)
                msg = 'The unique values of eventID do not match the number of elements in eventNameList.';
                assert(isequal(numel(unique(obj.eventID)), numel(obj.eventNameList)), errID, msg);
            end
            % Display trigger stats:
            if b_verbose
                disp('Trigger detection completed.')
                disp('---------- Trigger info ----------')
                deltaT = [diff(obj.timestamps); nan];
                fprintf(['Total number of triggers: %d\nTotal number of conditions: %d\n' ...
                    'Average trial length (HIGH state): %0.3f s\nAverage inter-trial length (LOW state): %0.3f s\n'...
                    'Trigger detection threshold: %0.2f v\nTrigger type: %s\n'],sum(obj.state),length(obj.eventNameList),...
                    mean(deltaT(obj.state == 1), 'omitnan'), mean(deltaT(obj.state == 0), 'omitnan'), obj.trigThr, ...
                    obj.trigType)
                disp('--------------------------------')
            end
            obj.clearIgnoredEvents; % Reset lists of ignored Condition and Repetitions
            % Try to set baseline period:
            if isempty(obj.baselinePeriod)
                obj.setBaselinePeriod;
            end
        end
        
        function f = plot(obj, chanName, varargin)
            % PLOT plots the analog input signals and overlays the threshold as well
            % as the detected triggers, if any.
            %
            % Input Arguments:
            %   chanName (char|cell): Channel name or list of names to plot.
            %   varargin (optional): Additional arguments including:
            %       fHandle (optional): Handle to figure or parent container to plot
            %           in. If not provided, a new figure will be created.
            %
            % Output Arguments (optional):
            %   f (handle): figure handle.
            %
            % Example:
            %   f = plot(obj, 'AI1');
            %   f = plot(obj, {'StimAna1', 'StimAna2'});
            %
            % Notes:                        
            %   - If no figure handle is provided, a new figure is created.                                    
            %   - Threshold lines and trigger patches are added if applicable.                        

            
            % Return if there are no ANALOGIN:
            if isempty(obj.AnalogIN)
                warning('No signal to plot!')
                return
            end
            % Force input to cell:
            if ischar(chanName)
                chanName = {chanName};
            end
            chanName = unique(chanName,'stable');
            
            % Check for figure/Parent container handle:
            f = [];
            if nargin > 2
                f = varargin{1};
            end
            % Create new figure, if no handle is provided:
            if isempty(f)
                f = figure('Name',sprintf('Analog Inputs (downsampled to %0.0f KHz)', 0.1*obj.sr),...
                    'NumberTitle','off','CreateFcn',{@movegui,'northwest'});
            end
            % Set subplot layout:
            nRows = ceil(sqrt(length(chanName))); 
            nCols = ceil(length(chanName)/nRows);
                                                
            % Check channel name(s):
            b_chanExists = ismember(chanName,obj.AIChanList);
            if all(~b_chanExists)
                error(['Invalid channel name(s). It must be one of the following:',sprintf('\n"%s"',obj.AIChanList{:})]);
            elseif any(~b_chanExists)
                warning(['The following channel(s) do not exist and will be ignored:', sprintf('\n"%s"',chanName{~b_chanExists})])
                chanName = chanName(b_chanExists);
            end
            [~,chanIndx] = ismember(chanName, obj.AIChanList);
            % Plot:
            % Set axes properties:
            xVec = [0:size(obj.AnalogIN,1)-1]./obj.sr;% Use X-axis in seconds
            axYSize = [min(obj.AnalogIN(:)), max(obj.AnalogIN(:))]; % Get min-max for Yscale
            evNames = obj.eventNameList(unique(obj.eventID(obj.selectedEvents)));
            for ii = 1:length(chanName)
                s(ii) = subplot(nRows,nCols,ii, 'Parent',f,'PlotBoxAspectRatio',[1,.35,1]);
                s(ii).YLabel.String = 'amp. (V)';
                title(s(ii), chanName{ii});
                hold(s(ii),'on');
                % Plot analogIN traces (downsample to 1KHz to save space):
                line(xVec(1:10:end),obj.AnalogIN(1:10:end,chanIndx(ii)),'LineStyle','-', 'Color',[.3 .3 .3],'Parent',s(ii));
                % Plot threshold line:
                if ~ischar(obj.trigThr)
                    ln = line(s(ii),[xVec(1) xVec(end)],[obj.trigThr obj.trigThr],'Color','r');
                    ln.Tag = 'thrLn';
                end
                % Plot Trigger patches:
                if ~isempty(obj.timestamps)
                    idx = unique(obj.eventID(obj.selectedEvents));
                    % Create semi-transparent patches to represent HIGH state of triggers:
                    % Trigger color code
                    colorArr = jet(64);
                    colorArr = colorArr(round(linspace(1,64,numel(evNames))),:);
                    for kk = 1:length(idx)
                        xOn = obj.timestamps(obj.eventID == idx(kk) & obj.state == 1 & obj.selectedEvents);
                        xOff = obj.timestamps(obj.eventID == idx(kk) & obj.state == 0 & obj.selectedEvents);
                        x = [xOn xOff xOff xOn];
                        y = repmat([axYSize(1) axYSize(1) axYSize(2) axYSize(2)], size(xOn));
                        ptc(kk) = patch(s(ii), x',y',colorArr(kk,:), 'FaceAlpha', .25, 'EdgeColor', 'none', 'Tag','TrigPatch');
                    end
                end
                % Put legend on the first plot:
                if ii == 1                    
                    legend(s(ii),ptc,evNames,'Location','northeast', 'Interpreter','none');
                end
                hold(s(ii),'off');
            end
            s(end).XLabel.String = 'time (s)';
            % Link all axes together
            linkaxes(s,'xy')
        end
        
        function status = readConditionFile(obj, varargin)
            % READCONDITIONFILE reads the content of an event file containing a
            % list of event Names. The file will be parsed using one of the
            % parsing methods available in this class (e.g., for .CSV,
            % .vpixx) and set by the "EventFileParseMethod" property. This
            % property is set at the class construction.
            % If the "EventFileName" is not provided, this function will
            % look for the file with the valid extension (.csv,
            % .vpixx) inside the "RawFolder" and parse it. Override this by
            % giving the full path of the "EventsFileName" as input.
            % For .CSV files, the list of events should be arranged in a
            % column with a HEADER (a header is necessary!) in the first row.
            % Multiple columns will be merged as a single event per row.
            % It is possible to select  a subset of columns by providing the
            % names of the columns "CSVcolNames" as input (Case sensitive!).
            %
            % Inputs (Optional):
            %   EventFileName (char): full path to a valid file containing
            %    the event IDs/Names to be parsed using the parse method set
            %    in the "EventFileParseMethod" property.
            %   CSVcolNames (cell): name of column(s) from a .CSV file to be
            %    read. If more than one column is provided, each row will
            %    be merged into a single one (this parameter is ignored for
            %    other parsing methods).
            % Output:
            %    status (bool): TRUE, if the event file was successfully
            %    read. FALSE otherwise.
            % Examples:
            %  1 - Automatic search for a .CSV file with a single column:
            %    readConditionFile();
            %  2 - Read an specific .CSV file:
            %    readConditionFile('C:/FULLPATH/FILENAME.CSV');
            %  3 - Read a subset of columns from a .CSV file:
            %    readConditionFile('CSVcolNames',{'Col1'',Col2','Col5'};
            %  4 - Read a subset o columns from an specific .CSV file:
            %    readConditionFile('C:/FULLPATH/FILENAME.CSV','CSVcolNames',{'ThisOne'});
            
            p = inputParser;
            addRequired(p,'obj')
            addOptional(p,'EventFileName','',@(x) ischar(x) | isempty(x));
            addParameter(p,'CSVcols',{''},@(x) iscell(x) & ischar([x{:}]));
            parse(p,obj,varargin{:});
            %
            evFile = p.Results.EventFileName;
            colNames = p.Results.CSVcols;
            %
            status = false;
            % Check if event file parsing method was set:
            if strcmpi(obj.EventFileParseMethod,'none')
                if ~isempty(evFile) || ~isempty(colNames{:})
                    warning('Operation aborted! EventFileParseMethod is not set yet.')
                end
                return
            end
            % Check if the trigger detection was already executed:
            if isempty(obj.eventID)
                warning('Operation aborted! Triggers missing. Detect triggers first, then read the event file to update the event IDs and names');
                return
            end
            % Use current event file:
            if ~isempty(obj.EventFileName) & isempty(evFile)
                evFile = obj.EventFileName;
            end
            
            if ~isempty(evFile)
                [folder,name,ext] = fileparts(evFile);
                if isempty(folder)
                    folder = obj.RawFolder;
                end
                if isempty(ext)
                    switch obj.EventFileParseMethod
                        case 'csv'
                            evFile = [name, '.csv'];
                        case 'vpixx'
                            if exist(fullfile(folder,[name, '.vpixx']),'file')
                                evFile = fullfile(folder,[name, '.vpixx']);
                            else
                                evFile = fullfile(folder,[name, '.txt']);
                            end
                        otherwise
                            error('Unknown file Parsing method')
                    end
                end
                
                % Check if the file exists. If not, raise a warning and
                % return:
                if ~exist(evFile,'file')
                    warning('Operation aborted. Events file "%s" does not exist!',evFile);
                    return
                end
                evFile = {evFile};
            else
                % For automatic detection of event files:
                fList = [dir(fullfile(obj.RawFolder,'*.csv'));...
                    dir(fullfile(obj.RawFolder,'*.vpixx'));...
                    dir(fullfile(obj.RawFolder,'*.txt'))];
                evFile = fullfile({fList.folder},{fList.name});
                if isempty([evFile{:}])
                    warning('Event list not found! Event IDs and names will not be updated!')
                    return
                end
            end
            % Try to parse files until it works:
            evID = []; evNames = {};
            for ii = 1:length(evFile)
                obj.EventFileName = evFile{ii};
                try % try-catch is here just to supress errors from private functions when non-event files are read. Errors or warnings will be raised here instead.
                    if strcmpi(obj.EventFileParseMethod,'csv') && endsWith(lower(obj.EventFileName), '.csv')
                        [evID, evNames] = obj.readCSVfile(colNames);
                    elseif strcmpi(obj.EventFileParseMethod,'vpixx') && (endsWith(lower(obj.EventFileName), '.vpixx') || endsWith(lower(obj.EventFileName), '.txt'))
                        [evID, evNames] = obj.readVpixxFile;
                        
                        % Add new parsing methods here.
                        %                elseif ...
                        %
                    else
                        continue
                    end
                catch
                    %%% Do nothing
                end
                if ~isempty(evID)
                    disp(['Event list updated from file "' obj.EventFileName '"'])
                    break
                end
            end
            % Throw warning if no event file was specified and no file was
            % successfully read:
            if isempty(p.Results.EventFileName) && isempty(evID)
                warning('Event File parsing aborted! Failed to parse "%s" file in "%s".\nDoes it exists in the Data Folder?',upper(obj.EventFileParseMethod), obj.RawFolder)
                return
            end
            assert(~isempty(evID),'Failed to parse "%s"! \nIs this a valid Event file?',obj.EventFileName)
            % Check if the eventID has the same length as the timestamps:
            assert(isequaln(length(obj.timestamps), length(evID)), 'Failed to update events from file "%s". There is a mismatch between the number of conditions and the number of triggers.', obj.EventFileName)
            % Save event ID and name lists:
            obj.eventID = evID;
            obj.eventNameList = evNames;
            obj.clearIgnoredEvents; % Reset lists of ignored Condition and Repetitions
            %
            status = true;
        end
        
        function removeCondition(obj, conditionName)
            % Add condition "conditionName" to the list of ignored conditions.
            % This will eliminate the whole condition, from the analysis
            % when the data will be split by events.
            if ~obj.validateCondition(conditionName);return;end
            obj.selectedEvents(obj.eventID == find(strcmp(conditionName,obj.eventNameList))) = false;
            fprintf('Condition "%s" will be ignored!\n',conditionName)
            % Warn user that all conditions are ignored:
            if ~any(obj.selectedEvents)
                warning('All conditions were ignored! Data splitting by events will be impossible!')
            end
            % Update selectedEvents field in current "events.mat" file:
            %             obj.updateEventsFile('selectedEvents')
        end
        
        function removeRepetition(obj, conditionName, repetitionIndex)
            % Adds the repetition "repetitionIndex" to the list of ignored
            % repetitions for a given condition "conditionName".
            % This will eliminate a specific repetition or a set of repetitions
            % from the analysis when the data will be split by events.
            
            if ~obj.validateCondition(conditionName);return;end
            if ~obj.validateRepetition(conditionName, repetitionIndex);return;end
            
            idxCond = obj.eventID  == find(strcmpi(conditionName,obj.eventNameList));
            
            obj.selectedEvents(idxCond & obj.repetitionID == repetitionIndex) = false;
            fprintf('Repetition "%d" from condition "%s" will be ignored!\n',repetitionIndex,conditionName);
            if all(~obj.selectedEvents(idxCond))
                warning('All repetitions from condition "%s" ignored. The whole condition will be ignored!\n',conditionName)
            end
            % Update selectedEvents field in current "events.mat" file:
            %             obj.updateEventsFile('selectedEvents')
        end
        
        function clearIgnoredEvents(obj)
            % Resets the lists of ignored conditions and repetitions to the default state (i.e. all trials included).
            if all(obj.selectedEvents(:));return;end
            % When there is no triggers detected. This should not be reached.
            if isempty(obj.eventID);obj.selectedEvents = [];return;end
            % Set logical matrix with TRUEs to keep all repetitions.
            obj.selectedEvents = true(size(obj.eventID));
            fprintf('Condition and Repetition lists successfully reset!\n');
            %             obj.updateEventsFile('selectedEvents')
        end
        
        function saveEvents(obj, saveFolder)
            % SAVEEVENTS creates the file "events.mat" in the
            % SaveFolder. This file is used by umIT to split the data into
            % trials.
            
            if nargin < 2
                % If no SaveFolder is provided, use the current value of
                % the SaveFolder propery:
                saveFolder = obj.SaveFolder;
            else
                % Update SaveFolder property:
                obj.SaveFolder = saveFolder;
            end
            if isempty(obj.timestamps)
                warning('Unable to create events.mat file. No triggers found!')
                return
            end
            %             % Trim all .dat files in the SaveFolder to exclude frames
            %             % outside trials:
            %             obj.trimDatFiles;
            % Save Events data:
            RawFolder = obj.RawFolder; %#ok
            AnalogIN = obj.AnalogIN;%#ok
            eventID = obj.eventID; %#ok
            timestamps = obj.timestamps; %#ok
            state = obj.state; %#ok
            eventNameList = obj.eventNameList; %#ok
            baselinePeriod = obj.baselinePeriod; %#ok
            trigChanName = obj.trigChanName; %#ok
            selectedEvents = obj.selectedEvents; %#ok
            EventFileName = obj.EventFileName;%#ok
            EventFileParseMethod = obj.EventFileParseMethod;%#ok
            % Save:
            save(fullfile(saveFolder, 'events.mat'),...
                'RawFolder',...
                'AnalogIN',...
                'eventID',...
                'state',...
                'timestamps',...
                'eventNameList',...
                'selectedEvents',...
                'baselinePeriod',...
                'EventFileName',...
                'EventFileParseMethod');
            disp(['Events MAT file saved in  ' saveFolder]);
        end
        
        function loadEvents(obj, Folder)
            % Load variables from events.mat file.
            if ~exist('Folder','var')
                if ~exist(fullfile(obj.SaveFolder,'events.mat'),'file')
                    % Consider the current folder the SaveFolder, if the input was not
                    % provided.
                    Folder = pwd;
                else
                    % Use the SaveFolder by default.
                    Folder = obj.SaveFolder;
                end
            end
            assert(any(exist(fullfile(Folder,'events.mat'),'file')), ['Failed to load event info! "events.mat" not found in ' Folder]);
            % Update SaveFolder:
            obj.SaveFolder = Folder;
            evInfo = load(fullfile(Folder,'events.mat'));
            fn = fieldnames(evInfo);
            % Get only existing fields:
            fn = intersect(fn,properties(obj),'stable');
            for ii = 1:length(fn)
                obj.(fn{ii}) = evInfo.(fn{ii});
            end
            % Load Acquisition info:
            obj.setInfo
            %
            if isempty(obj.selectedEvents)
                obj.clearIgnoredEvents;
            end
            if isempty(obj.baselinePeriod)
                obj.setBaselinePeriod;
            end
            fprintf('Events info loaded from folder %s\n', Folder);
        end
        
        function [frMat, conditionList, repetitionList] = getFrameMatrix(obj,varargin)
            % GETFRAMEMATRIX generates a matrix with dimensions Repetition x Frame indices
            % for each trial. The matrix output consists of the
            % frame indices split by trial (repetition). The matrix can be
            % used to split imaging data by trials and perform
            % event-triggered calculations.
            % This function outputs the matrix in 3 modes, depending on the inputs:
            %   1) No inputs (default): all conditions and repetitions
            %   2) conditionName only: all trials for the given condition
            %   3) conditionName + repetitionIndex: trials for the given
            %      repetition(s) of the selected condition.
            %
            % Inputs:
            %   obj: The object containing the data and methods.
            %   conditionName (char): Name of the condition to extract the trials.
            %   repetitionIndex (vector, int | optional): Repetition index(ices) of
            %       the condition. If not provided, all repetitions will be used.
            % Outputs:
            %   frMat (matrix): Matrix containing the frame indices of each trial.
            %       Frames that are out of bounds are marked as NaNs.
            %   conditionList (vector): List of conditions indices for each trial.
            %   repetitionList (vector): List of repetition indices for each trial.
            
            % Input parsing and validation:
            p = inputParser();
            addRequired(p,'obj');
            addOptional(p,'conditionName','',@(x) ischar(x) | isStringScalar(x) )
            addOptional(p,'repetitionIndex',[],@(x) ( isnumeric(x) && all(x > 0) ) || isempty(x))
            %
            parse(p,obj,varargin{:});
            conditionName = convertStringsToChars(p.Results.conditionName);
            repetitionIndex = p.Results.repetitionIndex;
            % Deny filtering repetition without condition name:
            if isempty(conditionName) && ~isempty(repetitionIndex)
                error('Repetition index cannot be set without the condition Name!')
            end
            
            [evIdx,conditionList, repetitionList] = obj.getEventIndex(conditionName,repetitionIndex);
            if isempty(evIdx)
                frMat = [];
                return
            end
            % Create frame index matrix:
            evOnsetFrame = round(obj.baselinePeriod*obj.AcqInfo.FrameRateHz);
            frOn = ceil(obj.timestamps(obj.state)*obj.AcqInfo.FrameRateHz);
            frStart = frOn - evOnsetFrame + 1;
            trialLen = [diff(frOn);max(diff(frOn))];
            frMat = nan(sum(obj.state),max(trialLen));
            
            for ii = 1:length(frStart)
                frVec = frStart(ii):frStart(ii)+trialLen(ii)-1;
                b_outbound_frames = frVec < 1 | frVec > obj.AcqInfo.Length;
                frVec(b_outbound_frames) = nan;
                frMat(ii,1:length(frVec)) = frVec;
            end
            
            % Update output matrix and lists:
            frMat = frMat(evIdx,:);
        end
        
        function [dataByEv, conditionList, repetitionList] = splitDataByEvents(obj,data,varargin)
            % SPLITDATABYEVENT uses the function getFrameMatrix to split 3D
            % image time series by trials.
            % Inputs:
            %
            %    data (3D num array): Image time series with dimensions Y, X, T.
            %    varargin: Optional parameters as name-value pairs!:
            %       'conditionName' (char or string): Name of the condition to filter trials.
            %       'repetitionIndex' (numeric array): Indices of repetitions to include.
            % Output:
            %    dataByEv (4D num array): Image time series by events with
            %       dimensions E, Y, X, T.
            %    conditionList (vector): List of condition indices for each trial.
            %    repetitionList (vector): List of repetition indices for each trial.
            
            % Input parsing and validation:
            p = inputParser();
            addRequired(p,'obj');
            addRequired(p,'data');
            addParameter(p,'condition','',@(x) ischar(x) | isStringScalar(x) )
            addParameter(p,'repetition',[],@(x) ( isnumeric(x) && all(x > 0) ) || isempty(x))
            
            parse(p,obj,data,varargin{:});
            
            % Check if the input data matches the dimensions stored in
            % AcqInfo:
            assert(isequaln(size(data),[obj.AcqInfo.Height, obj.AcqInfo.Width, obj.AcqInfo.Length]),...
                'Failed to split data by events! The dimensions of the input data do not match the ones in the AcqInfo structure!');
            % get frame matrix
            [frMat,conditionList, repetitionList] = obj.getFrameMatrix(p.Results.condition,...
                p.Results.repetition);
            % Split the data:
            dataByEv = nan(size(frMat,1),size(data,1),size(data,2),size(frMat,2),'single');
            b_validFrames = ~isnan(frMat);
            for ii = 1:size(frMat,1)
                dataByEv(ii,:,:,b_validFrames(ii,:)) = data(:,:,frMat(ii,b_validFrames(ii,:)));
            end
            % Crop trials to remove frames full of nans:
            if any(isnan(frMat(:)))
                disp('Cropping trials to shortest length...');
                dataByEv(:,:,:,find([0 diff(any(isnan(frMat),1))] == 1,1,'first'):end) = [];
            end
            disp('Finished splitting data by events');
        end
        
        function evInfo = exportEventInfo(obj)
            % EXPORTEVENTINFO packages the event-related information into a structure.
            %
            fieldsToExport ={'eventNameList','baselinePeriod'};
            evInfo = struct();
            for ii = 1:length(fieldsToExport)
                evInfo.(fieldsToExport{ii}) = obj.(fieldsToExport{ii});
            end
            % Add Frame Rate:
            evInfo.FrameRateHz = obj.AcqInfo.FrameRateHz;
            % Add EventID:
            evInfo.eventID = obj.eventID(obj.state);
            % Add selectedEvents:
            evInfo.selectedEvents = obj.selectedEvents(obj.state);
        end
        
    end
    
    methods %(Access = {?DataViewer})
        function [tmstmp,state]= getConditionTimestamps(obj,conditionName,varargin)
            % GETCONDITIONTIMESTAMPS outputs the timestamps of the
            % condition "conditionName".
            tmstmp = [];state = [];
            if ~obj.validateCondition(conditionName);return;end
            repetitionIndex =[];
            if nargin>2
                repetitionIndex = varargin{1};
            end
            evIdx = obj.getEventIndex(conditionName,repetitionIndex);
            % Duplicate evIdx to account for falling triggers:
            evIdx = repelem(evIdx,2);
            tmstmp = obj.timestamps(evIdx);
            state = obj.state(evIdx);
        end
        
        function [evIdx,conditionList, repetitionList] = getEventIndex(obj,conditionName,repetitionIndex)
            % GETEVENTINDEX Retrieves event indices based on condition and repetition.
            %   This function retrieves indices of events based on
            %   specified condition name and repetition index.
            %   It is a helper function for "getFrameMatrix","splitDataByEvents"
            %   and "getConditionTimestamps".
            %
            %   Inputs:
            %       - conditionName: Name of the condition to filter events.
            %       - repetitionIndex: Index of the repetition to filter events.
            %
            %   Outputs:
            %       - evIdx: Logical array indicating filtered event indices.
            %       - conditionList: Array containing condition IDs of the events.
            %       - repetitionList: Array containing repetition indices of the events.
            %   Notes:
            %       - Here, the indices and lists are set using the
            %           "obj.state" == 1.
            %       - If conditionName is empty, all conditions are considered.
            %       - If repetitionIndex is empty, all repetitions are considered.
            %       - The option of having no condition and a repetition is not allowed;
            %           if conditionName is empty, repetitionIndex should also be empty.
            
            % Check condition name:
            evIdx = [];
            conditionList = [];
            repetitionList = [];
            if ~isempty(conditionName)
                bOk = obj.validateCondition(conditionName);
            else
                conditionName = obj.eventNameList;
                bOk = true;
            end
            if ~bOk;return;end
            % Get condition index:
            condIdx = ismember(obj.eventID,find(ismember(obj.eventNameList,conditionName)));
            if ~isempty(repetitionIndex)
                bOk = false(length(repetitionIndex));
                for ii = 1:length(repetitionIndex)
                    bOk(ii) = obj.validateRepetition(conditionName, repetitionIndex(ii));
                end
            else
                repetitionIndex = obj.repetitionID(condIdx);
            end
            evIdx = ( obj.state & condIdx & ismember(obj.repetitionID,repetitionIndex)& obj.selectedEvents );
            conditionList = obj.eventID(evIdx);
            repetitionList= obj.repetitionID(evIdx);
            evIdx = evIdx(obj.state);
        end
    end
    
    methods (Access = private)
        function setInfo(obj)
            % SETINFO reads the content of the "AcqInfoStream" structure in the
            % SaveFolder and updates the fields for retrocompatibility.
            % In addition, it uses the information to update the properties:
            % "sr" and "trigChanName" (for trigger detection).
            
            % Load existing info:
            try
                a = load(fullfile(obj.SaveFolder, 'AcqInfos.mat'));
                obj.AcqInfo = a.AcqInfoStream;
            catch
                obj.AcqInfo = ReadInfoFile(obj.RawFolder);
            end
            
            % Get AnalogIN channel list:
            fn = fieldnames(obj.AcqInfo);
            idxChan = startsWith(fn,'AICh', 'IgnoreCase',true);
            if ~any(idxChan)
                % For retrocompatibility with older versions of the "info.txt"
                %   file where the names of AIchannels are not set. Here, we
                %   infer the names of the channels based on the total number of channels:
                
                % Initiate list with the names of the CameraTrigger and internal
                % channels, then,
                obj.AIChanList = cell(obj.AcqInfo.AINChannels,1);
                switch obj.AcqInfo.AINChannels
                    case 1
                        % Cage system:
                        obj.AIChanList(1) = {'CameraTrig'};
                        idx = 2;
                    case {2,6,10}
                        % Cage (n=2) or OiS200 (n=6,10) system. Camera and single internal trigger:
                        obj.AIChanList(1:2) = {'CameraTrig', 'StimAna1'};
                        idx = 3;
                    case {3,7,11}
                        % Cage (n=3) or OiS200 (n=7,11) system. Camera and double internal triggers:
                        obj.AIChanList(1:3) = {'CameraTrig', 'StimAna1', 'StimAna2'};
                        idx = 4;
                    otherwise
                        error('Failed to infer channel names from "info.txt" file!')
                end
                for ii = 0:obj.AcqInfo.AINChannels-idx
                    % Fill the rest of the channel names with the analog IN
                    obj.AIChanList{ii+idx} = ['AI', num2str(ii+1)];
                end
                % Add fields to AcqInfo property:
                for ii = 1:length(obj.AIChanList)
                    obj.AcqInfo.(['AICh' num2str(ii)]) = obj.AIChanList{ii};
                end
            else
                obj.AIChanList = cellfun(@(x) obj.AcqInfo.(x),fn(idxChan),'UniformOutput',false);
            end
            
            % Validate if the list of channel names match the number of
            % channels:
            assert(isequaln(length(obj.AIChanList),obj.AcqInfo.AINChannels),...
                'Mismatch found between list of channel names and total number of channels! Check "info.txt" file!')
            % Validate if all AnalogIN names exist in the dictionary. (This
            %   will keep devs up-to-date on changes in the "info.txt" file)
            assert(all(ismember(lower(obj.AIChanList), lower(obj.dictAIChan))),'Unexpected AnalogIN channel name found in "info.txt" file!');
            % Update Analog input sample rate:
            obj.sr = obj.AcqInfo.AISampleRate;
            
            % Update trigger names:
            if any(startsWith(fn,'event','IgnoreCase',true))
                % For digital stimulation:
                obj.b_isDigital = true;
                obj.trigChanName = 'StimDig';
                return
            end
            % Update trigger names for Analog Stims:
            b_hasStim1 = any(cellfun(@any,regexpi(fn,'stimulation1_')));
            b_hasStim2 = any(cellfun(@any,regexpi(fn,'stimulation2_')));
            if ~any([b_hasStim1, b_hasStim2])
                return
            end
            names = {'StimAna1','StimAna2'};
            obj.trigChanName = names([b_hasStim1, b_hasStim2]);
            % Use the pulse information from analog stim to update the
            % minimal interStim interval for detection of bursts stim.
            % blocks. We set the minimal interstim as the largest pulse
            % interstim with an extra 15%.
            idxBurst = contains(fn,'burst_delay','IgnoreCase',true);
            idxPeriod = contains(fn,'_period','IgnoreCase',true);
            idxFreq = contains(fn,'_frequency','IgnoreCase',true);
            if any(idxBurst) && obj.AcqInfo.(fn{find(idxBurst,1,'first')}) > 0
                % Use burst delay
                burst_delay = obj.AcqInfo.(fn{find(idxBurst,1,'first')});
                stim_period = obj.AcqInfo.(fn{find(idxPeriod,1,'first')});
                obj.minInterStim = 1.15*(burst_delay + stim_period)/1000; % Add 15% to the value of the burst delay
            elseif any(idxPeriod)
                % Use the pulse period
                obj.minInterStim = 1.15*(obj.AcqInfo.(fn{find(idxPeriod,1,'first')}))/1000;% Add 15% to the value of the pulse period
            else
                % Calculate the pulse period from frequency (older
                % "info.txt" versions)
                obj.minInterStim = 1.15*(1/obj.AcqInfo.(fn{find(idxFreq,1,'first')}));% Add 15% to the value of the pulse period
            end
            
        end
        
        function [timestamps, state] = detectTrig(obj, data)
            % DETECTTRIG detects the triggers from a given signal and
            %   outputs the timestamps and state. THis function is called by
            %   the method "getTriggers".
            % Input:
            %    data(1xN num. vector): vector containing the triggers.
            % Outputs:
            %    timestamps (num vect.): time delay (in seconds) of triggers detected.
            %    state (num vect.): state of the trigger: 1 = rising; 0 = falling.
            
            timestamps = single.empty();
            state = uint8.empty();
            % Check if "data" is a vector;
            validateattributes(data,{'single','double'},{'vector'});
            %
            if size(data,1) > size(data,2)
                data = data';
            end
            % Check for biphasic signal:
            % Here, a biphasic signal is considered to have a positive
            % followed
            % a negative pulse.
            if ~isequaln(data,abs(data))
                disp('Biphasic signal detected.')
                data = abs(data);
            end
            %
            if strcmpi(obj.trigThr, 'auto')
                trigAmp = (.8*(max(data(:)) - min(data(:))));
                % Control for the minimal amplitude for trigger detection
                if trigAmp < obj.minTrigAmp
                    warning('Operation Aborted! The trigger amplitude is too low for automatic detection! Manually set a threshold and try again.');
                    return
                end
                % Update trigger threshold value:
                obj.trigThr = trigAmp + min(data(:));
            end
            
            % Find samples that cross the threshold (rising and falling):
            tmRise = find(data < obj.trigThr & [data(2:end) nan] > obj.trigThr);
            tmFall = find(data > obj.trigThr & [data(2:end) nan] < obj.trigThr);
            if isempty(tmRise)
                return
            elseif numel(tmRise) ~= numel(tmFall)
                % Need to decide what to do in this case. For now, throw a
                % warning.
                warning('Number of rising and falling edges are not equal!')
                return
            end
            timestamps = single([tmRise tmFall]./obj.sr);
            state = [ones(1,numel(tmRise), 'uint8') zeros(1,numel(tmFall), 'uint8')];
            % Sort arrays by time and flip:
            [timestamps,idx] = sort(timestamps);
            timestamps = timestamps';
            state = state(idx)';
            % For Toggle type triggers:
            if strcmpi(obj.trigType, 'edgetoggle')
                % Use 2nd signal onset as the trial "OFF" state:
                timestamps = timestamps(state==1);
                % Overwite state:
                state = ones(sum(state),1,'uint8');
                state(2:2:end) = 0;
            end
            
            % Deal with bursts stimuli:
            StimLim = find(diff(timestamps(state ==1)) >= obj.minInterStim); %
            NbStim = length(StimLim)+1;
            if NbStim < sum(state) && ~obj.b_isDigital
                disp('Burst stim detected.')
                BurstOff = [StimLim; length(tmFall)];
                BurstOn = [1; StimLim+1];
                % Update timestamps and state:
                tmRise = tmRise(BurstOn);
                tmFall = tmFall(BurstOff);
                % Recalculate the timestamps and state:
                timestamps = single([tmRise tmFall]./obj.sr);
                state = [ones(1,numel(tmRise), 'uint8') zeros(1,numel(tmFall), 'uint8')];
                % Sort arrays by time and flip:
                [timestamps,idx] = sort(timestamps);
                timestamps = timestamps';
                state = state(idx)';
            end
            % Update timestamps and states for digital stim. Digital stim
            %   will only have a toggle marking the stim onset and the
            %   duration (in seconds) is recorded in the "info.txt" file.
            if obj.b_isDigital
                fn = regexp(fieldnames(obj.AcqInfo),'Stim\d+','match','once');
                fn(cellfun(@isempty,fn)) = [];
                stimInfo = cellfun(@(x) obj.AcqInfo.(x), fn);
                durationMap = containers.Map([stimInfo.ID],[stimInfo.Duration]);
                durationOrder = arrayfun(@(x) durationMap(x), obj.AcqInfo.Events_Order);
                timestamps = reshape([timestamps(state == 1)'; timestamps(state ==1)' + durationOrder],numel(state),[]); % Create timestamps to mark the end of the stim (trigger + duration_sec);
            end
        end
        %%%%% Event File parsers %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function [eventID, eventNameList] = readCSVfile(obj, colName)
            % READCSVFILE reads a .CSV file. If no column name is provided,
            % it reads the content of the first column.
            % If one column name is provided, it reads the rows of the
            % given column. If 2 or more column names are provided, the
            % values of the column names are concatenated with a hiphen ("-").
            %
            % Input:
            %    colName(optional, char|cell): column name(s) to be read
            %    from the CSV file.
            % Outputs:
            %    eventID (num vect.): list of indices of the events listed
            %    in "eventNameList".
            %    eventNameList (cell): list of event names in alphabetical
            %    order.
            % Set CSV reading rules:
            opts = detectImportOptions(obj.EventFileName);
            if ~exist('colName','var') || isempty(colName)
                colName = {''};
            elseif ischar(colName)
                colName = {colName};
            end
            
            if ~isempty([colName{:}])
                opts.SelectedVariableNames = colName; % Select the input columns only.
            else
                colName = {''}; % Use first column and skip header.
                opts.DataLines(1) = 2;
            end
            %             opts.DataLines = 2; %Start reading at 2nd row.
            opts.VariableTypes = repmat({'char'},size(opts.VariableTypes)); % Force data to characters.
            opts.MissingRule = 'omitrow'; % Remove rows with missing values.
            opts.ExtraColumnsRule = 'ignore'; % Ignore empty columns.
            % Read .CSV file:
            out = table2cell(readtable(obj.EventFileName,opts));
            % Merge multiple columns into a single one:
            nameList = cell(size(out,1),1);
            for ii = 1:size(out,1)
                if ~isempty([colName{:}])
                    nameList{ii} = strjoin(reshape(vertcat(colName,out(ii,:)),1,[]),'-');
                else
                    nameList{ii} = strjoin(out(ii,:),'-');
                end
            end
            eventNameList = unique(nameList,'stable');
            nameMap = containers.Map(eventNameList,1:length(eventNameList));
            eventID = zeros(length(nameList),1);
            for ii = 1:length(nameList)
                % Generate event ID from event name index.
                eventID(ii) = nameMap(nameList{ii});
            end
            % Duplicate the eventID to account for low state (considering
            % that there is no overlap between conditions).
            eventID = repelem(eventID,2);
        end
        
        function [eventID, eventNameList] = readVpixxFile(obj)
            % READVPIXXFILE extracts the condition ID, name and timestamps (if applicable)
            %   from the RAW DATA section of a .txt or .vpixx file.
            % Outputs:
            %    eventID (num vect.): list of indices of the events listed
            %    in "eventNameList".
            %    eventNameList (cell): list of event names in alphabetical
            %    order.
            
            % Extract only the part of the text containing the real sequence of
            %   conditions (RAW DATA section):
            filetext = fileread(obj.EventFileName);
            [~,idx_start] = regexp(filetext, 'RAW DATA');
            idx_stop = regexp(filetext, 'SORTED');
            filetext = strip(filetext(idx_start+1:idx_stop-1));
            if isempty(filetext)
                return
            end
            tab = strsplit(filetext, '\n')';
            % Get stimulus ID and order. Ignore Event and Time columns for now!
            out = {};
            myCols = [2 3]; % Keep just Condition and Stimulus.
            for i = 2:length(tab)
                str = strsplit(tab{i},'\t');
                if isempty(str{1})
                    % Skip Event rows.
                    continue
                end
                out = [out;str(myCols)];
            end
            out(:,1) = cellfun(@str2double, out(:,1), 'UniformOutput',false);
            eventID = [out{:,1}]';
            IDs = unique(eventID);
            eventNameList = cell(length(IDs),1);
            for ii = 1:length(IDs)
                idx = find(eventID == IDs(ii),1,'first');
                eventNameList(ii) = out(idx,2);
            end
            % Duplicate the eventID to account for low state (considering
            % that there is no overlap between conditions).
            eventID = repelem(eventID,2);
        end
        %%%% Validators %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function bOk = validateCondition(obj, conditionName)
            % Validates if the input condition exists in the
            % "eventNameList" and if it is not ignored. ATTENTION: !Case Insensitive!
            validateattributes(conditionName,{'char'},{'scalartext'});
            % Check if the selectedEvents propery was already set:
            assert(~isempty(obj.selectedEvents),'List of selected Events not set yet! Execute getTriggers and try again!');
            
            bOk = false;
            indxCond = find(strcmpi(conditionName, obj.eventNameList));
            % Check if it exists:
            if ~any(indxCond)
                error('The condition with name "%s" does not exist in the "eventNameList".', conditionName);
            end
            % Check if it was not blacklisted:
            if all(~obj.selectedEvents(obj.eventID == indxCond))
                warning('The condition with name "%s" is already listed as ignored!',conditionName)
                return
            end
            bOk = true;
        end
        
        function bOk = validateRepetition(obj, conditionName, repetitionIndex)
            bOk = false;
            % Validates if the input repetition exists and if it it is not ignored.
            validateattributes(repetitionIndex,{'single','double'},{'scalar'});
            % Validate the condition name first:
            obj.validateCondition(conditionName);
            % Check if the repetitionIndex provided is valid:
            assert(ismember(repetitionIndex,obj.repetitionID(obj.eventID == find(strcmp(conditionName,obj.eventNameList)))),...
                'The repetition index provided is out of bounds!')
            
            repIdx = ( obj.eventID == find(strcmp(conditionName,obj.eventNameList)) & obj.repetitionID == repetitionIndex );
            
            if ~obj.selectedEvents(repIdx)
                warning('The repetition "%d" from the condition "%s" is already listed as ignored!',repetitionIndex,conditionName);
                return
            end
            bOk = true;
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function delete(obj)
            % Class destructor. Re-enables original warnings.
            warning(obj.warnOrigState)
        end
        
        %         function updateEventsFile(obj,fieldname)
        %             % Updates a given field in an existing "events.mat" file.
        %
        %             if ~isfile(fullfile(obj.SaveFolder,'events.mat'))
        %                 return
        %             end
        %             evFile = matfile(fullfile(obj.SaveFolder,'events.mat'),'Writable',true);
        %             evFile.(fieldname)= obj.(fieldname);
        %         end
    end
end


