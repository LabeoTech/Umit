function status = runScriptOnFolder(folder, scriptName,fileFlag,varargin)
% RUNSCRIPTONFOLDER - Execute a MATLAB script within a specified folder.
%
% This function executes a MATLAB script within a specified folder and tracks
% the script's impact on files within the folder. It captures file status
% information (Unmodified, Modified, New, Deleted) and generates a log file.
%
% Inputs:
%   - folder (char): The folder where the script will be executed.
%   - scriptName (char): The name of the script to execute. If the .m extension is
%     missing, it will be added automatically.
%   - fileFlag (char| cell ): File type to list from folder (see "getFileList.m" for
%     details). Character or cell array of characters.
%   - extFlag (char): File extension of the script. If DataViewer is
%       deployed as an executable, the script will be saved in plain text
%       format (.txt). In this case, use ".txt" as value for this input.
%
% Returns:
%   - status (logical): A boolean value indicating the execution status
%     (true for successful, false for failed).
%
% Notes:
%   - The scriptName parameter can specify either the script name with or without
%     the .m extension. It is advisable to add the full path of the script,
%     if it is not in Matlab's path already.
%   - The log file generated by this function captures script details, execution
%     status, error messages, and file status before and after script execution.
%   - File status can be 'Unmodified', 'Modified', 'New', or 'Deleted'.
%   - The log file is saved with a name like 'log_yyyymmddHHMMSS.txt'.
%   - Make sure the specified folder exists.

p = inputParser;
addRequired(p,'folder',@isfolder);
addRequired(p,'scriptName',@(x) isfile(x) | isfile([x '.m']));
addRequired(p,'fileFlag');
addOptional(p,'extFlag','.m',@(x) ismember(x, {'.m','.txt'}));
parse(p,folder,scriptName,fileFlag,varargin{:});
extFlag = p.Results.extFlag;
clear p

% Check if the scriptName has a .m extension and add it if missing.
if ~endsWith(scriptName, extFlag)
    scriptName = [scriptName, extFlag];
end
origFolder = pwd;
% Add the script to the MATLAB path.
scriptFolder = fileparts(scriptName);
if isempty(scriptFolder)
    % Force full path to the original script from current directory
    scriptName = fullfile(pwd,scriptName);
end
% Change the current working directory to the specified folder.
cd(folder);
% Get information about all files before script execution (only imaging data files).
fileInfo_preExec = cellfun(@(x) dir(fullfile(pwd, x)), getFileList(pwd, fileFlag));
% Execute the script and capture any errors.
try
    % Initialize variables.
    status = true;
    execTimeStamp = now;
    errorReport = '';
    [~,name,~] = fileparts(scriptName);
    localScriptName = fullfile(pwd,[name extFlag]);
    
    % Remove original script from Matlab's cache:
    clear(scriptName);
   
    if strcmpi(extFlag, '.m')
        % Execute matlab script in current folder:
        bAdd2Path = false;
        % Add local copy of the script and use it. This will ensure that Matlab
        % will not change the current directory to the one from the script.
        if ~strcmp(scriptName, localScriptName)
            copyfile(scriptName,localScriptName);
            % Remove original script from path:
            if any(which(scriptName))
                rmpath(fileparts(scriptName))
            end
            bAdd2Path = true;
        else
            addpath(fileparts(scriptName));
        end
        % Execute local copy of script
        run(localScriptName);    
    else
        % In case where the script is saved in .txt format. This is a
        % special case used only in DataViewer deployed as an executable.
        txt = fileread(scriptName);
        eval(txt);
    end    
catch ME
    status = false;
    % Create report from failed script execution in folder:
    %     errorReport = getReport(ME, 'basic', 'hyperlinks', 'off');
    errorReport = getReport(ME, 'extended', 'hyperlinks', 'off'); % For testing
    disp(errorReport);
end
if bAdd2Path
    % Put the original script back to Matlab's path:
    addpath(fileparts(scriptName));
    % Remove local copy of script:
    delete(fullfile(pwd,[name extFlag]));
end
% Get information about all files after script execution.
fileInfo_postExec = cellfun(@(x) dir(fullfile(pwd, x)), getFileList(pwd, fileFlag));
% Classify each file status after script execution.
[fileStatus, fileInfo_postExec] = classifyFileStatus(fileInfo_preExec,fileInfo_postExec);
% Create a log using the genLog function.
genLog(scriptName, status, errorReport, table({fileInfo_postExec.name}', fileStatus', 'VariableNames', {'File', 'Status'}), execTimeStamp);
% Revert current directory to original:
cd(origFolder);
end

% Local functions
function [fileStatus, fileInfo_postExec] = classifyFileStatus(fileInfo_preExec, fileInfo_postExec)
% CLASSIFYFILESTATUS - Classify the status of files based on pre- and post-execution information.
%
% This function compares the properties of files in two sets of file information,
% fileInfo_preExec (before script execution) and fileInfo_postExec (after script execution),
% and classifies each file's status as one of the following:
%
% - 'Unmodified': The file remains unchanged.
% - 'Modified': The file has been modified.
% - 'New': The file is new and was not present before execution.
% - 'Deleted': The file was present before execution but is now deleted.
%
% Parameters:
%   - fileInfo_preExec: Information about files before script execution.
%   - fileInfo_postExec: Information about files after script execution.
%
% Returns:
%   - fileStatus: A cell array of strings representing the status of each file.
%   - fileInfo_postExec: Updated file information including any newly added files.

fileStatus = cell(size(fileInfo_postExec));
for jj = 1:length(fileInfo_postExec)
    if isempty(fileInfo_preExec) || ~any(strcmp(fileInfo_postExec(jj).name, {fileInfo_preExec.name}'))
        fileStatus{jj} = 'New';
        continue
    end
    
    if ~isequaln(fileInfo_postExec(jj).datenum, fileInfo_preExec(strcmp(fileInfo_postExec(jj).name, {fileInfo_preExec.name}')).datenum)
        fileStatus{jj} = 'Modified';
    else
        fileStatus{jj} = 'Unmodified';
    end
end
if isempty(fileStatus)
    % No files found in folder. Return: "No Files"
    fileStatus = {'---'};
    fileInfo_postExec.name = '---';
    return
end
if ~isempty(fileInfo_preExec)
    % Deal with deleted files:
    % Append list of deleted files:
    idxMiss = ~ismember({fileInfo_preExec.name}',{fileInfo_postExec.name}');
    if any(idxMiss)
        fileInfo_postExec = [fileInfo_postExec; fileInfo_preExec(idxMiss)];
        fileStatus = [fileStatus; repmat({'Deleted'},sum(idxMiss),1)];
    end
end
if size(fileStatus,1)> size(fileStatus,2)
    fileStatus = fileStatus';
end
if size(fileInfo_postExec,1)> size(fileInfo_postExec,2)
    fileInfo_postExec= fileInfo_postExec';
end
end

function genLog(scriptName, status, errMsg, fileTable, execTime)
% GENLOG - Create a log file for script execution.
%
% GENLOG creates a text file that captures details of a script execution,
% including script information, execution status, error messages, file status,
% and the script's content.
%
% Inputs:
%   - scriptName (char): The name of the executed script.
%   - status (logical): The execution status (true for successful, false for failed).
%   - errMsg (char): Error message in case of failure.
%   - fileTable (table): Table containing file status information.
%   - execTime (double): Execution date and time (in MATLAB's datenum format).
%
% Notes:
%   - The log file will be saved with a name in the format 'log_yyyymmddHHMMSS.txt'.
%   - In case of successful execution, the error message will be empty ('').
%   - The log contains sections for script information, file status, and error messages.
%   - The script's content is included in the log.

% Remove path from scriptName:
[~,name,~] = fileparts(scriptName);

% Create a mapping for boolean status values to descriptive labels.
boolMap = containers.Map([false true], {'Failed', 'Successful'});

% Create a log header.
header = sprintf('Script name: "%s"\nFolder name: "%s"\nExecution date time: "%s"\nExecution status: "%s"',...
    name, pwd, datestr(execTime, 'HH:MM:ss dd/mm/yyyy'), boolMap(status));

% Convert the file table to text.
fileTabTxt = tableToTextConverter(fileTable);

% Read the contents of the executed script.
scriptTxt = fileread(scriptName);

% Calculate the maximum line width for formatting.
mxErrMsg = diff(regexp(errMsg,'\n')); if isempty(mxErrMsg); mxErrMsg = length(errMsg);end
maxWidth = max([diff(regexp(header, '\n')), diff(regexp(fileTabTxt, '\n')), diff(regexp(scriptTxt, '\n')), mxErrMsg]);

% Create the log text.
if ~isempty(errMsg)
    % Create log with error message:
log = sprintf('+%s+\n%s\n+%s+\n%s\n+%s+\n%s\n+%s+\n%s\n+%s+',...
    pad('----- Batch Processing Log ', maxWidth, 'right', '-'), header,...
    pad('----- File status after script execution ', maxWidth, 'right', '-'),...
    fileTabTxt, pad('----- Error Messages ', maxWidth, 'right', '-'),...
    errMsg, pad('----- Copy of the script executed ', maxWidth, 'right', '-'),...
    scriptTxt, pad('', maxWidth, 'right', '-'));
else
    % Create log without error messages:
    log = sprintf('+%s+\n%s\n+%s+\n%s\n+%s+\n%s\n+%s+',...
    pad('----- Batch Processing Log ', maxWidth, 'right', '-'), header,...
    pad('----- File status after script execution ', maxWidth, 'right', '-'),...
    fileTabTxt, pad('----- Copy of the script executed ', maxWidth, 'right', '-'),...
    scriptTxt, pad('', maxWidth, 'right', '-'));
end
% Save the log to a file.
logFileName = 'log_batch_process.txt';
if isfile(logFileName)
    % Append current log to log file;    
    old_log = fileread(logFileName);   
    % Append new log to existing one:
    log = sprintf('%s\n\n%s',log,old_log);
end
fid = fopen(logFileName, 'w');
fwrite(fid, log);
fclose(fid);
end