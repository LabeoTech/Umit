function outData = temporal_filter(data, metaData, varargin)
% This function applies a band-pass 4th-order Butterworth filter to the Time
% dimension of an image time series (Y,X,T) dataset. 
% The filtering algorithm consists in creating two low-passed versions of the 
% signal with a given cut-off frequency ("LowCutOff" and "HighCutOff") and 
% subsequently subtracting the two filtered signals. 
% In this case, the signal(R) is expressed as DeltaR.
% Optionally, the subtracted signals can be normalized to the low cut-off signal 
% to express the signal as DeltaR/R.

% Limitations:
% The data must be an Image time series with dimensions
% {Y,X,T}.
% This function is a wrapper of the IOI library function "NormalisationFiltering.m".
% For more information on the algorithm, refer to the function's documentation.

% Output:
% outData (3D numerical array) : filtered data from "File".

default_Output = 'BPtemporalFilter.dat';  %#ok. This line is here just for Pipeline management.

%%% Arguments parsing and validation %%%
p = inputParser;
% Validate if the input is an existing ".dat" file or a 3-D numerical
% matrix:
addRequired(p,'data',@(x) isnumeric(x) & ndims(x) == 3);
addRequired(p,'metaData', @(x) isa(x,'matlab.io.MatFile')); % MetaData associated to "data".
% Optional Parameters:
% opts structure;
default_opts = struct('LowCutOffHz', .0033, 'HighCutOffHz', 0, 'Normalize', true); 
% Some notes on the CutOff values:
    % 1) The HighCutOffHz value of 0 will be translated as the Nyquist of the sample rate
    % 2) For the LowCutOff, values equal or less than zero will give a low-passed signal at "HighCutOff". 
addOptional(p, 'opts', default_opts,@(x) isstruct(x) && ~isempty(x));
% Parse inputs:
parse(p,data, metaData, varargin{:});
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Initialize Variables:
outData= p.Results.data;
metaData = p.Results.metaData;
opts = p.Results.opts;
clear p
%%%%


% Validata if Data is an Image Time Series:
errID = 'umIToolbox:temporal_filter:InvalidInput';
errMsg = 'Wrong Input Data type. Data must be an Image time series with dimensions "X", "Y" and "T".';
assert(all(ismember(metaData.dim_names,{'Y', 'X', 'T'})), errID, errMsg);

% Find NaNs and replace them with zeros:
idx_nan = isnan(outData);
outData(idx_nan) = 0;
% Run Temporal filter function
outData = NormalisationFiltering('', outData, opts.LowCutOffHz, opts.HighCutOffHz, ...
    opts.Normalize, metaData.Freq);
% Put NaNs back to data:
outData(idx_nan) = NaN;
end



% Validation function
function mustBeFileData(fileIn)
errID = 'umIToolbox:temporal_filter:InvalidInput';
if ischar(fileIn)
    if ~all(isfile(fileIn) & endsWith(fileIn, '.dat'))
        msg = [fileIn ' is not a .DAT file!'];        
        throwAsCaller(MException(errID,msg))
    end
elseif  ~all(isnumeric(fileIn) & ndims(fileIn) == 3)
    msg = 'Input data is invalid! Must be a 3D numerical matrix.';
    throwAsCaller(MException(errID,msg))
end
end